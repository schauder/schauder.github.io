---
layout: post
status: publish
published: true
title: Welche Bedeutung bekommt Concurrency f&Atilde;&frac14;r Enterprise Applications
author:
  display_name: Jens Schauder
  login: admin
  email: jens@schauderhaft.de
  url: http://blog.schauderhaft.de
author_login: admin
author_email: jens@schauderhaft.de
author_url: http://blog.schauderhaft.de
wordpress_id: 55
wordpress_url: http://blog.schauderhaft.de/2008/06/12/welche-bedeutung-bekommt-concurrency-fur-enterprise-applications/
date: '2008-06-12 17:18:07 +0200'
date_gmt: '2008-06-12 16:18:07 +0200'
categories:
- Softwaredevelopment
tags:
- Security
- agile
- vision
- Concurrency
comments: []
---
<p>Wenn man sich auf <a href="&#47;2008&#47;05&#47;19&#47;jax-08-sprachen-concurrency-security-architektur&#47;">IT-Blogs<&#47;a> und <a href="http:&#47;&#47;jax2007blog.it-agile.de&#47;2007&#47;04&#47;concurrency-past-and-present.html">Konferenzen <&#47;a>tummelt ist immer wieder die Rede von Concurrency, und wie wichtig das in Zukunft wird. Fakt ist sicherlich das Moorsche Gesetz in seiner alten Form ist am Ende. Wir werden uns mit immer mehr Kernen in unseren CPUs herumschlagen m&Atilde;&frac14;ssen. Fakt ist aber auch: Datenbanken und Webserver mit vielen Usern sind schon super parallelisiert. Bleiben die Clientrechner, und Webanwendungen bzw. Datenbanken mit nur wenigen Benutzern.</p>
<p>Ich denke im ersten Schritt wird das, was schon seit jeher zu den Best Practices geh&Atilde;&para;rt wichtiger: Lang laufende Aktionen werden in ihren eigenen Thread ausgelagert, damit der Benutzer nicht auf die Abarbeitung warten muss. Aber dies lastet die Prozessoren noch nicht besser aus, denn die lang laufenden Aktionen laufen lange, weil auf Ressourcen gewartet wird: Die Antwort vom Web Service, von der Datenbank oder vom Filesystem. Das ganze wird nur fixer, weil man auf drei Dinge gleichzeitig warten kann. Aber warten kann schon eine CPU mit einem Kern ziemlich gut auf ziemlich viele Dinge.Die eigentliche Frage: Was tun mit den andere Prozessoren &#47; Kernen bleibt also. Ich sehe zur Zeit zwei Alternativen:</p>
<ul>
<li>&Acirc;&nbsp;Wir finden keine gute Antwort auf die Frage. Dies w&Atilde;&curren;re in der Tat fatal, denn das Moorsche Gesetz treibt die gesamte IT Industrie! Warum soll ich mir einen neuen Rechner kaufen, wenn die Software so schnell l&Atilde;&curren;uft wie auf dem alten? Warum soll ich mir neue Software kaufen, wenn die auch nicht mehr kann als die alte, da sie die gleichen Ressourcen zur Verf&Atilde;&frac14;gung hat wie die alte? Ich halte diese Bedrohung f&Atilde;&frac14;r durchaus ernst und wundere mich, dass ich diesen Gedanken noch nirgends so gelesen habe.<&#47;li>
<li>Wir tun komplexere Dinge. Der gr&Atilde;&para;&Atilde;&Yuml;te Teil der der Anwendungen, die wir schreiben ist doch erschreckend banal: Benutzer gibt Daten ein, wir schubsen die Daten von hier nach da, drehen sie auf links und schreiben sie schlie&Atilde;&Yuml;lich in eine Datenbank. Wirklich komplexe Aufgaben wie Optimierungsprobleme oder Simulationen, anspruchsvolle 3D-Visualisierungen von Daten, stehen bei den meisten Entwicklern nur sehr selten im Pflichtenheft. Das hat zweierlei Gr&Atilde;&frac14;nde. Einerseits sind nur wenige Entwickler von 'Enterprise Applications' in der Lage solche Probleme zu l&Atilde;&para;sen, andererseits ist die Hardware schon mit den einfachen Dingen komplett ausgelastet. Aber letzteres wird sich &Atilde;&curren;ndern. Auf einem normalen PC werden wir schon bald ein Dutzend Prozessorkerne haben, die nicht richtig ausgelastet sind. Wenn wir dem Kunden neue Versionen unserer Software verkaufen wollen, m&Atilde;&frac14;ssen wir ihm zeigen, dass wir mit dieser Rechenleistung etwas anfangen k&Atilde;&para;nnen. Berechnungen und Optimierungen, die wir bisher als nicht handhabbar abgetan haben, und dem Benutzer &Atilde;&frac14;berlassen haben, m&Atilde;&frac14;ssen wir uns krallen, in parallel verarbeitbare Algorithmen gie&Atilde;&Yuml;en, nett visualisieren und in die Anwendung integrieren.<&#47;li><br />
<&#47;ul><br />
Daher meine apokalyptische Prophezeiung: Wer als Software Entwickler in 10 Jahren noch einen Job haben will, sollte hoffen dass Java sich zum n&Atilde;&curren;chsten Cobol entwickelt, und f&Atilde;&frac14;r Leute mit veraltetem Wissen viel Geld bezahlt wird, oder sie sollte sich schon mal an <a href="http:&#47;&#47;20bits.com&#47;2007&#47;05&#47;08&#47;introduction-to-dynamic-programming&#47;">nicht triviale Algorithmen<&#47;a> herantasten.</p>
