---
layout: post
status: publish
published: true
title: Hibernate Sessions in Two Tier Rich Client Applications
author:
  display_name: Jens Schauder
  login: admin
  email: jens@schauderhaft.de
  url: http://blog.schauderhaft.de
author_login: admin
author_email: jens@schauderhaft.de
author_url: http://blog.schauderhaft.de
wordpress_id: 99
wordpress_url: http://blog.schauderhaft.de/2008/09/28/hibernate-sessions-in-two-tier-rich-client-applications/
date: '2008-09-28 11:10:33 +0200'
date_gmt: '2008-09-28 10:10:33 +0200'
categories:
- Softwareentwicklung
- Java
tags: []
comments:
- id: 49
  author: Fabio
  author_email: fabiomaulo@gmail.com
  author_url: ''
  date: '2008-09-30 22:50:28 +0200'
  date_gmt: '2008-09-30 21:50:28 +0200'
  content: "Very good article.\r\nNHibernate (the .NET version of Hb) users have the
    same problem with WindowsApplication.\r\nI'm trying to implement a solution using
    session-per-application-transaction pattern for application that are using MVP
    pattern... but as you know... this is a long story."
- id: 69
  author: Vishal
  author_email: i_am_ajay_singh@yahoo.com
  author_url: http://tree
  date: '2008-11-13 00:03:33 +0100'
  date_gmt: '2008-11-12 23:03:33 +0100'
  content: "Nice Article !!!\r\nI am facing the same issue."
- id: 133
  author: Ewan Makepeace
  author_email: MAKEPEACE@JAWASOFT.COM
  author_url: ''
  date: '2009-02-06 12:20:37 +0100'
  date_gmt: '2009-02-06 11:20:37 +0100'
  content: "We too are facing the same problems on the .NET side. The Hibernate team
    are just a bit too smug about how awful the world would be if Hibernate just opened
    a new session every time it needed to lazy load a collection, but in fact the
    problems they have created are much bigger than the ones they describe, when you
    are talking about rich client apps.\r\nThe whole point of using Hibernate is to
    encapsulate persistence to make your code clean. The problems described above
    mean that session handling and persistence concerns must be embedded all over
    your code (and often in the UI where you want it least!).\r\n\r\nIf anyone has
    further references on this subject would love to hear about them. I cant believe
    there is so little good info on this subject..."
- id: 145
  author: Richard
  author_email: hangstrap@gmail.com
  author_url: ''
  date: '2009-03-05 02:43:36 +0100'
  date_gmt: '2009-03-05 01:43:36 +0100'
  content: We are trying to write a rich application using ZK framework http:&#47;&#47;www.zkoss.org&#47;
    where the rich client applications run as a session variable on web  server. So
    in our case we also have to consider sessions maintained across multiple http
    request&#47;responses - add yet another layer of complexity.....
- id: 153
  author: aappddeevv
  author_email: aappddeevv@verizon.net
  author_url: ''
  date: '2009-03-28 17:22:07 +0100'
  date_gmt: '2009-03-28 16:22:07 +0100'
  content: "You can have a session stay open within a RCP based on the lifetime of
    the unit of work which is typically an editor screen of some sort while still
    having different session patterns on other editors windows in the same thread
    by using orchestra and spring. By placing DAOs or services into a special scope
    that intercepts all methods on those DAOs and swaps out the session on the thread
    and then replaces it after the method complete automatically using orchestra.
    Orchestra is from a myfaces implementation. This makes conversational control
    placed into the scope versus using program code. This is essentially what jboss's
    seam does. \r\n\r\nIn the worse case you can just create your DAO objects with
    the long-lived session object directly and maintain the session object in your
    editor state somewhere. Then just ensure that all other DAOs that are called use
    that same session by initializing them with it as well. This approach is harder
    but also doable.\r\n\r\nThe only other way is to do the second approach via code
    instead of a container which makes configuration more laborious but is what many
    RCPs have done over the years.\r\n\r\nSupposedly the new JSR 299 (or something
    like that) will address conversational scope and should apply to RCPs."
- id: 154
  author: Jens Schauder
  author_email: jens.schauder@lineas.de
  author_url: http://blog.schauderhaft.de
  date: '2009-03-28 21:13:43 +0100'
  date_gmt: '2009-03-28 20:13:43 +0100'
  content: "Hi Aappddeevv,\r\nwell I just added Orchestra (http:&#47;&#47;myfaces.apache.org&#47;orchestra&#47;)
    to the many thing I'd like to investigate. It sounds interesting in deed. Yet
    so far I fail to see how one could specify the scope of a conversation in an easy
    way. Do you have more detailed sources for that?"
- id: 206
  author: sola
  author_email: soltesz.andras@gmail.com
  author_url: ''
  date: '2009-05-27 16:27:03 +0200'
  date_gmt: '2009-05-27 15:27:03 +0200'
  content: "Great article!\r\n\r\nOf course rich client applications have a lot of
    other problems like this:\r\n- Database connection needs to get through firewalls\r\n-
    The database connection can be easily broken over the Internet (we use PostgreSQL
    and have to implement reconnection functionality because the connection so often
    get lost on long distance sessions)\r\n\r\nI really like rich clients but the
    ORM frameworks most often simply don't consider the extra needs of these kinds
    of apps which makes them hard to develop.\r\n\r\nWe also opted for the one Session
    for one Frame approach (or something very similar)."
- id: 222
  author: Milan
  author_email: madamovic@lbmsystems.com
  author_url: ''
  date: '2009-06-03 17:44:09 +0200'
  date_gmt: '2009-06-03 16:44:09 +0200'
  content: "Excellent article!\r\n\r\nHere is my concern: how to handle database errors&#47;constraint
    violations. The scenario is as follows. User changes several records in a grid
    or in different parts of one form (frame). When user saves the changes, hibernate
    flushes all changes to the database. Some of the changes are successful and some
    of them fail DB constraints. Ideally, you would want to navigate to the UI element
    that caused the constraint failure, and give the user a chance to fix the error,
    while preserving the valid changes. \r\n\r\nHere is an excerpt from Hibernate
    documentation: \"If the Session throws an exception (including any SQLException),
    you should immediately rollback the database transaction, call Session.close()
    and discard the Session instance. Certain methods of Session will not leave the
    session in a consistent state. No exception thrown by Hibernate can be treated
    as recoverable. Ensure that the Session will be closed by calling close() in a
    finally block.\"\r\n\r\nIf there are multiple failures, it gets even more complicated.\r\n\r\nYour
    thoughts on the error handling subject would be much appreciated."
- id: 223
  author: Jens Schauder
  author_email: jens.schauder@lineas.de
  author_url: http://blog.schauderhaft.de
  date: '2009-06-03 17:55:21 +0200'
  date_gmt: '2009-06-03 16:55:21 +0200'
  content: "Hi Milan,\r\nyou are absolutely right, this is a problem that needs consideration.\r\n\r\nI
    absolutely recommend to validate all input against the constraints before flushing
    the session. In the project on which this article is based we basically used a
    NakedObject appraoch (http:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Naked_objects)
    although we didn't know it at that time. So we actually used the constraints as
    defined in the hibernate mapping to create checks&#47;special UI control in the
    UI layer. So for Foreign Keys one only could choose by picking from a list, other
    values where checked using hibernate validation.\r\n\r\nIf everything fails and
    you actually get a sql exception due to a constraint violation the session is
    dead, which sucks, but is seldom.\r\n\r\nAn alternative approach is to edit data
    in special objects and then copy the content of those objects into the session
    objects. This results in much shorter session live time (which probably is a good
    thing), and of course you could recover more easily after an exception. But you
    need to create a seperate set of objects (possibly classes), which makes life
    even more complecated then it is already. ...\r\n\r\nAs a German saying goes:
    You have to die one death"
- id: 252
  author: Milan
  author_email: madamovic@lbmsystems.com
  author_url: ''
  date: '2009-07-20 22:12:05 +0200'
  date_gmt: '2009-07-20 21:12:05 +0200'
  content: "Hi Jens,\r\n\r\nRegarding the constraints validation in the client, that
    is definitely the best approach when possible. However there are certain constraints
    that are more convenient to validate in DB or they perform better there, such
    as Unique Key, or complex business rules implemented in DB triggers.\r\n\r\nI
    did some experimenting with the error handling and found out the session does
    not die after a SQL constraint exception (at least I could not make it die). If
    you handle exception and subsequently fix the data that caused the constraint
    to fail, everything works properly at the end. You can have multiple DML operations
    and fail only some of them, commit or rollback at the end (intentionally), etc.\r\n\r\nSo
    here is my idea about how to apply this to user interface. Trap every focus&#47;selection
    change event that causes the underlying data context to change, and flush the
    session each time. Catch the error, display it (in a dialog) and do not allow
    changing the selection until the error is corrected (or the changes are rolled
    back). I successfully implemented a simple prototype that follows this approach.
    The biggest hurdle for me is to find proper events where to flush the session.
    (I am using SWT and it is not working as I would expect it.)"
- id: 253
  author: Jens Schauder
  author_email: jens.schauder@lineas.de
  author_url: http://blog.schauderhaft.de
  date: '2009-07-29 20:10:02 +0200'
  date_gmt: '2009-07-29 19:10:02 +0200'
  content: "Hi Milan,\r\nI'd be super carefull with this approach. I would love if
    it works, but it will always be without support of the hibernate team, so if it
    failes at some point you will be on your own completely. One case which I would
    expect problems with is: how does it handle the dirty state of objects that already
    got flushed successfully? Is it set to 'not dirty' as it probably should? What
    if the sql exception happens on an update that happens in mutiple steps, which
    might be the case when manipulating references.\r\n\r\nIf you want to go down
    this road I'd check the source code, write some tests and then propose a patch
    for the hibernate team to make it an official feature. This way you know (to some
    extend) it works, and it will get some support from the hibernate team and the
    community as well."
- id: 410
  author: Vlad Sadilovskiy
  author_email: vlovsky@gmail.com
  author_url: ''
  date: '2010-03-23 20:19:38 +0100'
  date_gmt: '2010-03-23 18:19:38 +0100'
  content: "Hi. \r\n\r\nI wanted to say that validating some type of constraints is
    not possible even conceptually in the application layer without locking tables
    that are involved in such validation. Consider unique key validation. The only
    way that guaranties uniqueness and would not throw a unique constraint violation
    is to do the following sequence of actions. 1. Lock the table from modifications
    2. Query this table for duplicates of an incoming data. 3. If no duplicates found,
    insert incoming data. 4. Unlock the table or commit transaction. This is workable,
    but in my opinion cannot be a solution for concurrent multi-user enterprise level
    application.\r\n\r\nAny other algorithm may render the assumptions of querying
    for duplicates invalid at the time of the insert."
- id: 411
  author: Jens Schauder
  author_email: jens.schauder@lineas.de
  author_url: http://blog.schauderhaft.de
  date: '2010-03-23 21:00:01 +0100'
  date_gmt: '2010-03-23 19:00:01 +0100'
  content: "Hi Vlad,\r\nYour assessment of validation unique constraints is absolutely
    correct. And for this reason I strongly recommend the use of database constraints,
    which do essentially what you describe with pretty good performance and very well
    tested.\r\n\r\nYet 'enforcing' this kind of constraint in the gui, without using
    the locking catches many cases of constraint violation, which would otherwise
    only get caught by the database, rendering the session unusable. \r\n\r\nThere
    is only a small gap left, for another user entering the same value at almost the
    same time and the database constraint takes care of that.\r\n\r\nThe performance
    cost of this approach is very limited, since we only use a select on an indexed
    column and no locking. \r\n\r\nSo for us it was a nice compromise between performance,
    ease of implementation and usability."
- id: 991
  author: Mathias De Belder
  author_email: m_debelder@hotmail.com
  author_url: ''
  date: '2010-10-10 14:09:31 +0200'
  date_gmt: '2010-10-10 12:09:31 +0200'
  content: "You can have lazy loading with already closed Sessions. We use it quite
    a bit at work which admittedly uses a three-tier architecture. But there is no
    reason you can't program against \"SessionFacades\" that do their work locally
    through DAOs which in turn delegate to Hibernate with a couple of connections
    from the client machines to the DB server.\r\n\r\nThe trick is to write your own
    EntityTuplizer (and register it with your Configuration object) that returns an
    implementation of the HibernateProxy interface (or implementations of the PersistentXYZ
    collection interfaces). When Hibernate creates a lazy reference it will always
    store the name of the association and a serializable PK blob. That can then be
    used to fetch the relation \"JIT\" in a <strong>new<&#47;strong> Session. For
    the collection interfaces you can get away with plain Java but for the case where
    the destination of a relation is a POJO you'll need to use a bytecode generation
    library like Javassist (like Hibernate uses already).\r\n\r\nSay you have a one-to-many
    relationship. You query the one-side with some constraints and you display the
    resultant entities in a JList. When the user clicks on an item, the \"many\"-relationship
    (usually a Set, but can be a POJO as well) is traversed. Under the covers, the
    PersistentXYZ collection will go through a special facade with the PK and association
    name to fetch the association just-in-time. The downside to this is that you can
    block the EDT with DB-access unknowingly. Usually the access is <250ms, so quite
    acceptable. If it&#039;s really becoming a problem after profiling we wrap the
    access in a SwingWorker and show a fancy \"please wait\" animation.\r\n\r\nOf
    course, at some level you still have to be cognizant that the objects you&#039;re
    dealing with are eventually fetched from a database. That&#039;s why we have methods
    on our SessionBeans that deliver a fairly \"wide\" object-graph for the client
    to begin with. The rest is fetched lazily (our Swing clients go through our app-server,
    but as noted before, the clients can use Hibernate directly).\r\n\r\nWe work exclusively
    with detached entities and merge them back in again when a user saves something
    in a form. This has the \"downside\" of needing a good equals() and hashCode()
    implementation but that will pay itself back big time down the line (although
    I had to fight many battles at work to make people not write hashCode() implementations
    that NPEd all the time). If you prime the L1 cache with a good query the merge
    will only have to perform insert&#47;update&#47;deletes. Fetching and persisting
    your entities is still not completely transparent (methods to select&#47;save
    a graph of objects on your facades) but still a whole lot better than the procedural
    nightmare of EJB2 with DTOs everywhere and different methods on your SessionBeans
    to traverse associations."
- id: 1148
  author: sola
  author_email: soltesz.andras@gmail.com
  author_url: ''
  date: '2010-11-18 13:29:24 +0100'
  date_gmt: '2010-11-18 11:29:24 +0100'
  content: "@Mathias\r\nGreat ideas for solving Hibernate problems.\r\n\r\nI am also
    rewriting my rich client application to work with completely detached objects
    and hacking lazy loading back into the game (not using Hibernate's default lazy
    loading).\r\n\r\nBy the way: A Hibernate session dying on you while saving a new&#47;modified
    object back to the database is the ugliest thing you can imagine. It is extremely
    hard to shake the session back to shape in order to continue using it. We do the
    following when saving: \r\n- We merge every dirty object into a session created
    specifically for the save operation (save session)\r\n- We save the objects, this
    may succeed or fail\r\n- We drop the \"save session\"  and merge objects back
    to the original session\r\n- If an object was meant to be saved but the save operation
    failed, we clear the ID field which was filled out during the save operation\r\n\r\nThis
    way the \"save session\" will always be dropped after the save attempt and cannot
    cause further problems after it failed once.\r\nThe original, \"query session\"
    will remain intact, even if the save operation failed."
- id: 1149
  author: sola
  author_email: soltesz.andras@gmail.com
  author_url: http://nostran.com
  date: '2010-11-18 13:36:38 +0100'
  date_gmt: '2010-11-18 11:36:38 +0100'
  content: "I am rewriting my pure-Swing application as a Netbeans RCP application.\r\n\r\nI
    believe I will create a DB Persistence Service Module which will be responsible
    for downloading data objects and writing them back to the database. This should
    handle lazy-loading as well. Ideally, this will have a server-side counterpart
    and the communication between them will be HTTP-only in order to avoid cutting
    through firewalls. This should be able to handle HTTP proxies.\r\n\r\nHibernate
    should not be visible, only JPA style annotations should be used on the data objects.\r\n\r\nIf
    someone knows about such persistence service (using JPA, with server and client
    side, communication is with HTTP) please, let me know (soltesz(point}andras (at)
    gmail dotcom).."
- id: 2901
  author: Illa Ades
  author_email: Greider5726@gmail.com
  author_url: http://spiritualground-forum.org/member.php?action=profile&amp;uid=49
  date: '2011-01-18 22:10:55 +0100'
  date_gmt: '2011-01-18 20:10:55 +0100'
  content: I am really thankful to this topic because it really gives great information
    :~,
- id: 3016
  author: Blaz Demsar
  author_email: blaz@milonguero.si
  author_url: ''
  date: '2011-02-07 18:28:10 +0100'
  date_gmt: '2011-02-07 16:28:10 +0100'
  content: "@Mathias \r\nI would like to try the sollution you are proposing, however,
    since I am relatively new in Hibernate, I am struggling with the implementation.
    Could you share a snapshot of the code? \r\nLG\r\nBlaz"
- id: 3051
  author: Mathias De Belder
  author_email: m_debelder@hotmail.com
  author_url: ''
  date: '2011-02-12 01:56:58 +0100'
  date_gmt: '2011-02-11 23:56:58 +0100'
  content: "@Blaz\r\n\r\nI can't just copy and paste our code on the web. However,
    the idea of using remote lazy loading has also been explored by other people.
    There's a fine article on <a href=\"http:&#47;&#47;www.theserverside.com&#47;news&#47;1363571&#47;Remote-Lazy-Loading-in-Hibernate\"
    rel=\"nofollow\">TheServerSide<&#47;a> that pretty much does exactly the same
    as what we have in place (apparently the source code snippets there are clipped,
    so be sure to check out the HTML source). Having lazily loaded entities is a bit
    harder than lazily loaded collections, so I'd advise to start off with the latter,
    which is actually pretty easy to implement. For lazily loaded entities you should
    really look at the Hibernate source code itself (start with https:&#47;&#47;github.com&#47;hibernate&#47;hibernate-core&#47;blob&#47;master&#47;hibernate-core&#47;src&#47;main&#47;java&#47;org&#47;hibernate&#47;proxy&#47;pojo&#47;BasicLazyInitializer.java)
    to grok how it's done and what parts you need to substitute. Poking around with
    a debugger in Hibernate's source code is quite instructive to get a clear picture
    of what's actually going on.\r\n\r\nThen it's simply a matter of replacing the
    bits in your Hibernate Configuration object:\r\n\r\nEntitityTuplizerFactory f
    = new Configuration().configure(\"some.cfg.xml\").getEntityTuplizerFactory();\r\nf.registerDefaultTuplizerClass(EntityMode.POJO,
    RemoteLazyEntityTuplizer.class);\r\n\r\n\r\nWhere RemoteLazyEntityTuplizer is
    a PojoEntityTuplizer specialization that returns a special ProxyFactory returning
    JavaAssist proxies (implementing MethodHandler and Hibernate's own LazyInitializer)
    that know how to get to your EJB facade when they need to be initialized."
- id: 4547
  author: Adam Dyga
  author_email: adeon@tlen.pl
  author_url: http://adyga.pl
  date: '2011-11-30 17:18:43 +0100'
  date_gmt: '2011-11-30 15:18:43 +0100'
  content: This is interesting solution. I'm trying to do similar thing using JPA&#47;Hibernate,
    but I'm concerned about one thing. If EntityManager throws an exception, according
    to docs, it should be immediately closed. How do you handle this situation if
    there are still some domain objects in the memory (GUI, eg. tree), that may still
    attempt to lazy-load data? Do you create new EntityManager and reset it in all
    places where it's used?
- id: 4548
  author: Jens Schauder
  author_email: jens@schauderhaft.de
  author_url: http://blog.schauderhaft.de
  date: '2011-11-30 17:53:46 +0100'
  date_gmt: '2011-11-30 15:53:46 +0100'
  content: "@Adam Dyga Yes that is basically what we do. We have a central place that
    stores the session for each Frame. If the session throws an exception it should
    get closed and removed and all the entities of the frame should get reloaded using
    a fresh session"
- id: 6693
  author: Not Relevant
  author_email: not.relevant@hotmail.com
  author_url: ''
  date: '2012-06-06 22:37:05 +0200'
  date_gmt: '2012-06-06 20:37:05 +0200'
  content: "There is plenty of info on the subject here:\r\n\r\n# Building N-Tier
    Applications\r\nhttp:&#47;&#47;msdn.microsoft.com&#47;en-us&#47;library&#47;bb896304.aspx\r\n\r\n#
    Working with Objects\r\nhttp:&#47;&#47;msdn.microsoft.com&#47;en-us&#47;library&#47;bb738470.aspx"
- id: 8207
  author: az
  author_email: andrei.f.z@gmail.com
  author_url: ''
  date: '2012-09-12 21:32:22 +0200'
  date_gmt: '2012-09-12 19:32:22 +0200'
  content: "it was a good concept of call stack, based on modality. In other words
    you can &acirc;&euro;&oelig;open&acirc;&euro;\x9D or &acirc;&euro;&oelig;call&acirc;&euro;\x9D
    a new object. \r\nA &acirc;&euro;&oelig;call&acirc;&euro;\x9D keeps the same session
    and if a commit issued everything within session will be committed.\r\nAn &acirc;&euro;&oelig;open&acirc;&euro;\x9D
    method will start a root of new session, for example open another instance of
    the object&acirc;&euro;&brvbar;"
- id: 10333
  author: Session management using Hibernate in a Swing application | Ask Programming
    &amp; Technology
  author_email: ''
  author_url: http://askprogramming.com/117027/session-management-using-hibernate-in-a-swing-application.html
  date: '2013-11-11 13:44:24 +0100'
  date_gmt: '2013-11-11 11:44:24 +0100'
  content: "[&#8230;] http:&#47;&#47;blog.schauderhaft.de&#47;2008&#47;09&#47;28&#47;hibernate-sessions-in-two-tier-rich-client-applications&#47;
    [&#8230;]"
- id: 14370
  author: George
  author_email: giorgos.ginis@gmail.com
  author_url: ''
  date: '2014-05-03 19:22:28 +0200'
  date_gmt: '2014-05-03 17:22:28 +0200'
  content: Hi Jens, and thank you for this post it was very helpful to see what can
    go wrong using hibernat along with swing! I have the same issues, on a small business
    ERP application that we have done, and we are now trying to use the hibernate
    libraries to make a simpler, cleaner and more reliable code. More specifically
    we are facing the issue of passing the objects from one frame&#47;view to another.
    I looked at the mediator pattern as you suggested, but I can not quite figure
    out how to apply it using DAOs. I was thinking to have a "manager" for our complex
    DAOs that will hold a variable of the object loaded from the DB. Any sub-views
    will be passed this manager in order to perform any operations needed on the loaded
    object. For example, you load a Person (that has a one-to many association to
    address), the user opens a new view to create an address for that Person, and
    when they hit "save" on the address view, then the controller invokes on the manager
    a method that adds the newly created address (which violates the session per frame
    suggestion).  When they return to the "home&#47;parent" view and hit save again,
    the person is saved with all its changes including the new address. I would appriciate
    any comments on that approach. If you can please give a short example of the mediator
    pattern of how is applied on DAOs it would be very much appriciated. thank you
    once more for all your help.
- id: 57185
  author: Jens Schauder
  author_email: jens@schauderhaft.de
  author_url: http://blog.schauderhaft.de
  date: '2014-05-25 10:27:30 +0200'
  date_gmt: '2014-05-25 08:27:30 +0200'
  content: "@Gorge\r\n\r\nwow, it's a long time since I wrote that post and since
    I thought about this kind of problem. \r\n\r\nViolating the session per view constraint
    is ok if you know what will happen: your two or more views now work on the same
    session. Whenever one triggers a commit, everything will be saved and the session
    closed. This basically means: it works if some views are some kind of subviews
    that don't commit any changes. And only the master view controls the transaction.
    Note that it gets difficult to handle a cancel action in the subviews once they
    have changed hibernate entities.\r\n\r\nAbout the Mediator Pattern:\r\nMy idea
    behind its use in this setup is that you need someone to handle the: \"Get a copy
    of this object in a fresh session and open a frame for editing&#47;viewing&#47;whatever
    it.\" So for example a view that lists entities and allows them to be selected
    for editing would call a mediator for opening the editor frame."
---
<p>One of the most populare articles in this blog so far ist the one about, well: <a href="&#47;2007&#47;12&#47;17&#47;hibernate-sessions-in-fat-client-anwendungen&#47;">Hibernate Sessions in Two Tier Rich Client Applications<&#47;a>. Although the original article is writen in german I keep refering to this article, even in english communities. Therefore I decided to break my habit of writing articles in german only and provide a english version which you are reading right now.</p>
<p>This is NOT a direct translation so there might be some differnces in scope, focus and detail.</p>
<p>Everybody working with Java and Databases is probably aware of Hibernate. It is a great solution for mapping a database schema to a object model. It is used in hundreds of applications. So on my current project we decided to use it as well. But big surprise. While Support in the user forum of hibernate is pretty good most of the time we hit one kind of a problem which had no apropriate solution available: How to handle Sessions in a Two Tier Hibernate Application (Swing or SWT typically).</p>
<p>How could such a essential problem be unsolved? Well Rich Client Applications are not hip anymore. Everybody goes for web applications and in that context the session handling is well understood and there is a easy straight forward solution that works in most cases: On each request open a session, do all your work including constructing the result (e.g. JSP) , close the session. But there is no equivalent for a request in a swing application. And since Rich Client Applications are kind of old fashioned nobody bothers to find (and write about) a clean solution for this problem.</p>
<p>We tried a lot of things, starting with the antipattern of a single session per application. This doesn't work at all for any kind of serious app for the following reasons:</p>
<ul>
<li>No transaction control between different parts of the application. When you flush&#47;commit a session, everything gets flushed. So imagine a application with two open edit frames. The user hits save in one frame and surprise, her half done changes in the other frame get saved as well. Not good.<&#47;li>
<li>Memory Leak. The Hibernate Session keeps track of every entity ever loaded by that session. So if you don't close the session from time to time the session will grow until the application blows up or the whole database is contained in the session. If nothing else this will cause performance issues.<&#47;li><br />
<&#47;ul><br />
Of course if you write a really small simple application this might work, but not for us. As said before we tried a lot of things to solve our problem in the assumption that our requirements are so common that it can't be hard to find the solution. We were wron. So if the solution to a problem isn't easy to find, what should be your first step? Wrong (probably)! Your first step should be to exactly identify the problem. In this case this meant: What are the requirements we had? What are the relevant features&#47;limitations of Hibernate? The requirements were:</p>
<ul>
<li>We want Lazy Loading: Lazy Loading is a real powerfull feature whe working with a rich domain model (as we did) especially in a Swing Application. You just display what every attribute you can reach by any kind of object navigation, hibernate will ensure the data is there. Awesome. This was one of the main selling points for Hibernate vs. plain JDBC. So it wasn't realy an option to loose it.<&#47;li>
<li>Different views of the same entity should show the same state. So if you edit an Object the same Object shown in some kind of list-view should show the updated state immediatly.<&#47;li>
<li>It should be obvious for the user what is going to be saved when she hits the save button.<&#47;li>
<li>The whole mechanism must be fairly easy to use, since the team was growing and not everybody was a hibernate expert. Also lazy loading problems are sometimes hard to debug and fix.<&#47;li><br />
<&#47;ul><br />
The relevant properties of the Hibernate session are</p>
<ul>
<li>For lazy loading to work an entity must be attached to a open session.<&#47;li>
<li>A entity wich contains at least one collection (which are well above 50% of our class) can only be attached to one session at a time.<&#47;li>
<li>A session keeps a reference to any entity it loads, until the entity get evicted or the session gets closed.<&#47;li>
<li>A Hibernate session guarantees to return the same instance everytime a specific entity is requested.<&#47;li><br />
<&#47;ul><br />
If you look at it in this compact form it is rather obvious that you can't have your cake and eat it too. The automatic refresh in all views of an object would be easily implemented, when there is only one session. But we simply couldn't do this. So the decision was made that the automatic refresh is (obviously) not as important as clean transactional control plus lazy loading. So we will have more then one session. But which part of the application is using which session? The Hibernate site uses the term 'Unit-of-Work'. Each unit of work should be contained in its own session. But this is basically back to step one. A request in a webapp ist a unit of work, but where is a unit of work in a rich client app? Imagine this example: The user fires up the application and opens a search dialog resulting in a list of objects. Clearly we are accessing the database, so we just startet a unit of work. Now she double clicks an item in the list. The entity gets opened in a editor, she edits it and hits save. Work commited, transaction closed, unit of work ended. Wow, thats easy, isn't it? No it isn't: She clicks on a different item, edits it, saves it. So now we have opened one session and closed two sessions. Not good.</p>
<p>The answer is actually fairly easy once found: Use one session per frame&#47;internal frame&#47;dialog. Modal dialogs use the session of the frame the got starteted from. Background tasks get their own session. The critical point is the transfer of objects from one frame to another. It is tempting to just pass the object but then you have a object from the wrong session in the frame. Instead pass just the Id (the primary key) and use that to load the object in the new session. This approach solved most of our problems nicely.</p>
<p>Most problems? Yes and no. We have some things that we don't like to much. I think I know how to solve them but I haven't implemented them yet. So I can't really promis anything.</p>
<ul>
<li>Instant refresh in other (readonly) views. When editing a object the changed state is not represented in other views of the same object. This could be fixed by a hibernate interceptor or event listener. It would listen for update events, then check if this entity is contained in any other session, check if that session is read only and if so trigger a refresh of that object. We haven't implemented that simple due to time constraints.<&#47;li>
<li>Saving in background. Most of the stuff we do is simple object editing, but on fairly complex object graphs. So saving an object to DB may take some time. Due to the tight integration of Frames and session we can't easily delegate this work to a background thread. The same is true of lazy loading. In long lists of complex objects scrolling to new cells for the first time might cause some lag, because lazy loading happens in the Event Handling Thread. The first part should be fairly easy to fix:Open a new Session, find the dirty Objects, merge the dirty Objects in the new Session, do a flush of the new session in a background thread. One just has to make sure the background thread uses its own instances, not the same instances as the original frame&#47;session. The lazy loading in background is more difficult to solve. For almost everything in the GUI we use a <a href="http:&#47;&#47;www.jgoodies.com&#47;index.html">JGoodies<&#47;a> PresentationModel and the associated ValueModels, so the swing objects don't access directly any attributes of our Hibernate entities. These ValueModel could be used to implement a seperation of two differnt threads: The Swing Event Handling Thread on one side and a seperate thread for all the model work, including lazy loading. But this would mean the whole application is split in two threads, instead of the normal aproach of having one main thread and a couple of worker threads for special work. I think it should be feasibly and actually enforces a very strict and clean architecture, and result in a highly responsive gui, but it would also be a lot of (debugging) work and as everybody knows: Concurrency is hard. So we decided that we don't need it in this application.<&#47;li><br />
<&#47;ul><br />
If you are going to implement this kind of session handling I strongly suggest to use a director&#47;mediator pattern for all your frames. While always a good idea, it becomes important in this case because it gives you a well defined spot to do your session handling. And of course you should be aware of the alternatives:</p>
<ul>
<li>Go with a single long living session. Only feasable with smallish applications<&#47;li>
<li>Kick Lazy Loading and close your session after retrieving your objects. This loses many of the interesting benefits hibernate offers.<&#47;li><br />
<&#47;ul><br />
In any case I how this write up shed some light on the issues and helped to make a informed decission.</p>
