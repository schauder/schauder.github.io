---
layout: post
status: publish
published: true
title: Why Hibernate is so much more powerful than JDBC
author:
  display_name: Jens Schauder
  login: admin
  email: jens@schauderhaft.de
  url: http://blog.schauderhaft.de
author_login: admin
author_email: jens@schauderhaft.de
author_url: http://blog.schauderhaft.de
wordpress_id: 115
wordpress_url: http://blog.schauderhaft.de/2008/11/27/why-hibernate-is-so-much-more-powerful-than-jdbc/
date: '2008-11-27 19:28:51 +0100'
date_gmt: '2008-11-27 18:28:51 +0100'
categories:
- Softwareentwicklung
- Java
- Datenbank
tags: []
comments:
- id: 76
  author: David Hofmann
  author_email: hofmanndavid@gmail.com
  author_url: http://hofmanndavid.blogspot.com
  date: '2008-11-28 13:27:05 +0100'
  date_gmt: '2008-11-28 12:27:05 +0100'
  content: Nobody can say that an airplane is more powerful than it's engines !
- id: 77
  author: Jens Schauder
  author_email: jens.schauder@lineas.de
  author_url: http://blog.schauderhaft.de
  date: '2008-11-28 13:46:51 +0100'
  date_gmt: '2008-11-28 12:46:51 +0100'
  content: But every plane with more than one engine is more powerful than a single
    engine!.
- id: 78
  author: Anonymous
  author_email: anon
  author_url: ''
  date: '2008-11-28 14:17:38 +0100'
  date_gmt: '2008-11-28 13:17:38 +0100'
  content: "Hibernate is certainly very powerful but one question remains to be answered:
    how can I optimize the generated sql queries to benefit from the full power of
    the underlying database engine ?\r\n\r\nPrecision: I'm talking of databases with
    tables having millions of rows. Having optimized queries is a necessity.\r\n\r\n\r\nTo
    my knowledge :\r\n\r\n1 - If you use ORM tools such as Hibernate and others, you
    have nearly no way to optimize the text of sql queries that are sent to the db
    engine. Just buy new hardware with more CPUs, more RAM and store your db in cache.
    I do not call this \"a solution\" but it may be ok for you, it depends on your
    cash.\r\n\r\n2 - If you can customize the text of the sql queries, then you can
    unleash the power of your database engine (Oracle, SqlServer, MySql, ...): they
    all have very powerful and very little-known capabilities such as analytical operators,
    cube operators and such.\r\n\r\nYou may also decide if, and when, argument binding
    with JDBC is a good thing or not (eg: on Oracle, binding is considered \"good\"
    on OLTP with 100's or 1 000's requests per second - but it can be considered \"bad\"
    in other environments such as web frontends, DW, ... because the query optimizer
    can not make the full use of table and index meta-data such as histograms or skew
    of the values stored in tables and indexes - that makes the difference between
    10 seconds query run time, or sub-second run time).\r\n\r\n==> Please correct
    me if Hibernate permits easy customization and maintenance of the sql queries
    sent to the database.\r\n\r\n\r\nFor the ones who wish to know more on that subject,
    you may Google on \"group by rollup\", \"group by cube\", \"group by grouping
    sets\", \"rank\", \"dense_rank\", \"lag\", \"lead\".\r\n\r\nI work with Oracle
    but other database engines have the same sort of extensions - this is not Oracle-specific.\r\n\r\nYou
    may also read http:&#47;&#47;www.nocoug.org&#47;download&#47;2001-11&#47;8i_analytical_features.ppt
    - this is based on a (very) old Oracle version but foundations still hold true.\r\n\r\nIMPORTANT:
    as an exercise, at each slide, try to write the same query using only what is
    called \"standard SQL\" (i.e. without analytical operators): when dealing with
    LAG and LEAD operators for example, or grouped running totals, you may discover
    new horizons."
- id: 80
  author: Jens Schauder
  author_email: jens.schauder@lineas.de
  author_url: http://blog.schauderhaft.de
  date: '2008-11-28 15:01:32 +0100'
  date_gmt: '2008-11-28 14:01:32 +0100'
  content: "You have many aproaches in optimizing the sql statements generated by
    hibernate: (and I assume similiar features for comparable ORM tools):\r\n\r\n-
    You can fiddle with the used dialect if you find something wrong with the generated
    sql on a fundamental level.\r\n- You can add sql snippets for calculating single
    attributes. Here combining analytic functions and hibernate works just great.\r\n-
    You can define custom sql statements to be used for CRUD (http:&#47;&#47;hibernate.org&#47;hib_docs&#47;v3&#47;reference&#47;en&#47;html&#47;querysql-cud.html)
    I had to look up that myself\r\n- you can obtain a jdbc connection and do whatever
    you like with it.\r\n\r\nI am well aware of features like rollups, cubes and analytic
    functions. (e.g &#47;2008&#47;08&#47;20&#47;sql-tricks-3-intervall-join&#47;).
    And they sure come in handy with reporting &#47; datawarehouse style application.
    \r\n\r\nBut also in many cases the SQL skills on a java heavy team arn't that
    great, so it is still beneficial to get 98% of the sql generated, working just
    fine. So you can use the extra time for tuning the queries, that really cause
    a problem."
- id: 81
  author: Mert Can Akkan
  author_email: mcakkan@yahoo.com
  author_url: http://www.altuure.com
  date: '2008-11-28 15:05:53 +0100'
  date_gmt: '2008-11-28 14:05:53 +0100'
  content: "One more vote for ORM, \r\nUse objects and relations not tables and foreign
    keys for more self documenting code and rapid development.\r\n\r\nhttp:&#47;&#47;www.altuure.com&#47;2008&#47;11&#47;12&#47;object-model-vs-database-schema-design&#47;\r\nhttp:&#47;&#47;www.altuure.com&#47;2008&#47;10&#47;22&#47;why-orm-cause&#47;"
- id: 138
  author: wow gold
  author_email: vgeirh@yahoo.com
  author_url: http://www.wotlkgolds.com
  date: '2009-02-20 06:01:18 +0100'
  date_gmt: '2009-02-20 05:01:18 +0100'
  content: A merry heart goes all the way
- id: 276
  author: dofus kamas
  author_email: mfxmz01@hotmail.com
  author_url: http://www.ibay24.fr
  date: '2009-10-07 07:04:06 +0200'
  date_gmt: '2009-10-07 05:04:06 +0200'
  content: 'You have many aproaches in optimizing the sql statements generated by
    hibernate: (and I assume similiar features for comparable ORM tools):'
- id: 277
  author: cheap Aion kinah
  author_email: mfxmz01@hotmail.com
  author_url: http://www.ibay24.de
  date: '2009-10-07 07:08:15 +0200'
  date_gmt: '2009-10-07 05:08:15 +0200'
  content: But also in many cases the SQL skills on a java heavy team arn&acirc;&euro;&trade;t
    that great, so it is still beneficial to get 98% of the sql generated, working
    just fine. So you can use the extra time for tuning the queries, that really cause
    a problem.
- id: 3524
  author: lgags2502pair3dglasses
  author_email: ka016@hotmail.com
  author_url: http://lgags2502pair3dglasses.you4u.cz.cc
  date: '2011-05-25 00:11:08 +0200'
  date_gmt: '2011-05-24 22:11:08 +0200'
  content: Cools_Web_Thank_for_shared
- id: 379078
  author: Bojan Dolinar
  author_email: bojandolinar@hotmail.com
  author_url: ''
  date: '2015-02-06 11:43:58 +0100'
  date_gmt: '2015-02-06 09:43:58 +0100'
  content: "It really depends on the type of application. Hibernate save you considerable
    amount of boiler-plate with OLTP-type applications, but is not very suitable with
    OLAP-type of applications. Two frustrating problems are documented here:\r\nhttp:&#47;&#47;glennpaulley.ca&#47;conestoga&#47;2013&#47;01&#47;introduction-to-hibernate&#47;"
---
<p>Should I use Hibernate for the next project? How does it compare to JDBC</p>
<p>This question get's asked a lot. And the first answer is most of the times: That is comparing apples and oranges. And of course that is true. But if you are a little kid apples are round and tasty and so are oranges, so it is a reasonable question what exactly is the difference between apples and oranges?</p>
<p>Both (Hibernate and JDBC not apples and oranges) are used for tying application logic to your database. Hibernate is actually using JDBC. Actually you can use Hibernate in a very similiar way as JDBC. So how exactly does one work with JDBC?</p>
<p>You create a connection, create query from that (using SQL), change the objects (carefully keeping track of what you changed), transform you change log in SQL Statements and send those to the database (using the old or a new connection).</p>
<p>If you don't like Hibernate, but are forced to use it you do it the same way:<br />
start a session, create a query from that (using HQL), disconnect the objects, change the objects, (carefully keeping track of what you changed), start a new session and use it to store the new state of the objects in the database.</p>
<p>So you are saving, the DML statements for storing the objects, therefore you have to learn HQL, Hibernate, and all the weird error messages you get from it.</p>
<p>But you can use Hibernate very differently:</p>
<p>Open a session, query for some objects (using Criteria), work with these and commit the session.</p>
<p>That is when the real power of hibernate reveals itself. You are using <strong>neither<&#47;strong> HQL <strong>nor<&#47;strong> SQL, at least for the standard tasks. This takes away a lot of the ugly kind of error you only get when you actually run the code. You don't have to keep track what exactly you changed. Hibernate is doing that for you. At least on the first go you don't have to worry when to load exactly what piece of information, instead Hibernate will do it on the fly for you (and of course you will have to control it in some cases where Hibernates choices aren't the right once).</p>
<p>But you can benefit from Hibernate even more: <a href="&#47;2008&#47;03&#47;06&#47;das-beste-buch-uber-software-design&#47;">Do the design<&#47;a> in the <a href="&#47;2008&#47;04&#47;03&#47;naked-objects&#47;">domain model<&#47;a>, i.e. design you model classes the way they should look like from an OO perspective, then add the necessary Hibernate Annotations, thereby deciding on mapping strategies for inheritance and the like. In my experience this results in a richer, more expressive domain model and in a <strong>cleaner <&#47;strong>database design.</p>
<p>The reason for this is, that by using this approach you are bringing the power of refactoring to the database! How about an experiment. Go to your favorite database administrator and tell her that someone was ignoring the naming conventions. A couple of table names (about 70) and a couple of columns (about 600) have to be changed, oh and someone hast to change all the sql statements as well. How are your chances to get this refactoring done? Zero? Not too long ago I had exactly that kind of change as a task. Iwas done after 4 hours! It was quite easy. I did the changes to the domain model using the refactoring features of the IDE, that was it (almost). I had to change about 4 or 5 special purpose HQL Statements, and semi automatically create a change script for the database. Yes this was on an application that was installed on a client side, so I had to take care of migration scripts.</p>
<p>I am not saying that you should do this kind of refactoring, but how often do you <a href="&#47;2008&#47;08&#47;22&#47;database-refactoring&#47;">refactor your database<&#47;a>? It is still considered voodoo science but with Hibernate you can at least use a powerful IDE and doen't have to put up with the crappy stuff you get from database tool vendors. With other tools not many people go through the trouble of changing a column name, because it is wrong in one way or the other. In Java I never stop changing a method or attribute name that I consider wrong as long as it isn't used in some public API of course.</p>
<p>As usual it comes at a cost.</p>
<ul>
<li>Hibernate has learning curve. People of hibernate.org claim do have learned hibernate in two weeks. I don't think so. They might know enough to use it. But just as with SQL or Java or whatever, it takes time to really master it.<&#47;li>
<li>Hibernate is no magic pixy dust. It makes decision and uses default. If those don't fit your needs, you might encounter problems, e.g. performance hits. In these cases you have to change the mapping, write HQL, or even SQL or do whatever needs doing to fix the problem.<&#47;li>
<li>If you are working with a legacy database or can't use the approach described above then the benefit from using Hibernate is smaller.<&#47;li><br />
<&#47;ul><br />
If you disagree, let me know in the comments. ff you agree, let me know as well.</p>
