---
layout: default
status: publish
published: true
title: Komplexität und die neuen Sprachen
author:
  display_name: Jens Schauder
  login: admin
  email: jens@schauderhaft.de
  url: http://blog.schauderhaft.de
author_login: admin
author_email: jens@schauderhaft.de
author_url: http://blog.schauderhaft.de
wordpress_id: 47
wordpress_url: http://blog.schauderhaft.de/2008/04/24/komplexitat-und-die-neuen-sprachen/
date: '2008-04-24 10:15:55 +0200'
date_gmt: '2008-04-24 09:15:55 +0200'
categories:
- article
- Softwareentwicklung
- Wissensmanagement
tags: []
comments: []
---
<p>Ein ganz großes Thema auf der JAX08 und in der Entwicklergemeinschaft sind Sprachen.<br />
Groovy, Ruby, JRuby, Skala und viele mehr. Warum?</p>
<p>Ich denke <a href="http://it-republik.de/jaxenter/jax/speaker.php?language=#15-wulff-prof.%20dr.%20nikolaus">Prof. Dr. Nikolaus Wulff</a> hat hier wertvolle Erklärungsansätze geliefert. In seiner Session <a href="http://it-republik.de/jaxenter/jax/sessions.php?tid=676#session-28">Die Grenzen der Komplexität</a> stellt er auf hoch amüsante Weise die folgende These auf: Ein komplexes System, also eins mit vielen Beziehungen zwischen den Teilen des Systems wechselt zwischen stabilen und instabilen Gleichgewichten. Die Java Gemeinschaft befand sich für lange Zeit in einem stabilen Gleichgewicht. Die anstehenden Probleme konnten mit Java gelöst werden, sie konnten insbesondere mit Java wesentlich besser gelößt werden, als z.B. durch C++ oder gar C. Aber viele dieser Probleme sind gelößt. Dadurch werden neue Probleme in Angriff genommen und hier stoßen wir an die Grenzen von Java. Dinge, die man früher nicht wahrgenommen hat, da man die Features von Java noch untersuchte. Vor ein paar Jahren hat fast niemand Closures vermisst, heute schreit die halbe Welt danach. Ebenso wie z.B. Struts 1 an seine Grenzen gestoßen ist, und wie die klassischen Prozessor Architekturen an ihre Grenzen stoßen. Oder alternativ formuliert: Wir suchen uns immer komplexere Probleme, bis wir sie mit den bisherigen Mitteln nicht mehr Lösen können.</p>
<p>Nun gibt es (wiederum nach Herrn Wulff) drei wesentliche Strategien.<br />
1. abwarten, vielleicht löst sich das Problem von alleine. Das funktioniert gut für lange Zeit, wenn man zufrieden damit ist in der 3. oder 4. Reihe mitzuspielen. Dies ist auch als Quake Tuning:  Um eine Anwendung um den Faktor 2 zu beschleunigen, schließt man sich für 18Monate Quake. Danach ist die Anwendung schneller.</p>
<p>2. Horizontale Ausweichbewegungen. Das Problem wird nicht wirklich gelößt sondern nur temporär umgangen. Als Beispiel nennt Herr Wulff Mehrkernarchitekturen, die nicht wirklich das Problem lösen, dass Schaltkreise nicht beliebig weiter verkleinert werden können. Oder auch das Verhalten einiger Entwickler bezüglich neuer Sprachen: Der Java Stack ist unglaublich kompliziert, mit Tausenden von Klassen und Bibliotheken. Die Ausweichbewegung: Man wähle eine neue Sprache und bekommt sofort Erfolgserlebnisse, ohne sich mit den nicht existenten tausenden von relevanten Bibliotheken herumzuschlagen: "Toll, es funktioniert: 'Hello World'".</p>
<p>3. Etwas wirklich Neues entsteht. Dies sind die wenigen Durchbrüche, die wirklich weiterhelfen. In der Hardware könnte dies vielleicht aus der Quantenmechanik kommen. In der Softwarebranche sind die neuen Sprachen die Suche nach etwas Neuem, auch wenn es für viele Entwickler nur eine Ausweichbewegung ist. Auch bei diesen Lösungen gilt aber der Satz von der Erhaltung der Komplexität: Komplexität verschwindet nicht. Sie kann versteckt werden, insbesondere in eine Sprache oder eine Bibliothek ausgelagert werden.</p>
<p>Und was bedeutet das für mich (und für euch)? Verschiedenes:</p>
<p>1. Wir werden nicht immer alle die nötige Genialität besitzen um eine Strategie der 3. Art zu fahren, aber wenigstens die 1. sollten wir vermeiden und man sollte sich bewusst sein, die 2. Strategie zu fahren, wenn man es tut.</p>
<p>2. <a href="/2008/01/07/wohin-geht-es-mit-java/">Java wird verschwinden oder sich radikal ändern</a> , aber nicht morgen. Man kann dies schön an den folgenden Graphen sehen. Sie stellen die Entwicklung und das Absolute Verhältnis von Jobangeboten für verschieden Programmiersprachen dar. Die Graphen werden bei www.indeed.com gezogen:</p>
<p style="width: 540px"> <a href="http://www.indeed.com/jobtrends?q=java%2C+ruby%2C+groovy%2C+skala&amp;relative=1&amp;relative=1" title="java, ruby, groovy, skala Job Trends"><br />
<img src="http://www.indeed.com/trendgraph/jobgraph.png?q=java%2C+ruby%2C+groovy%2C+skala&amp;relative=1" alt="java, ruby, groovy, skala Job Trends graph" border="0" height="300" width="540" /><br />
</a></p>
<table style="font-size: 80%" border="0" cellpadding="6" cellspacing="0" width="100%">
<tr>
<td><a href="http://www.indeed.com/jobtrends?q=java%2C+ruby%2C+groovy%2C+skala&amp;relative=1&amp;relative=1">java, ruby, groovy, skala Job Trends</a></td></p>
<td align="right"><a href="http://www.indeed.com/jobs?q=java">java jobs</a> - <a href="http://www.indeed.com/jobs?q=ruby">ruby jobs</a> - <a href="http://www.indeed.com/jobs?q=groovy">groovy jobs</a> - <a href="http://www.indeed.com/jobs?q=skala">skala jobs</a></td><br />
</tr><br />
</table><br />
Wie man sieht, wachsen die neuen Sprachen rasant, während Java stagniert.<br />
Aber Java stagniert auf hohem Niveau, um nicht zu sagen, sie sind irrelevant für Jobs</p>
<p style="width: 540px"> <a href="http://www.indeed.com/jobtrends?q=java%2C+ruby%2C+groovy%2C+skala" title="java, ruby, groovy, skala Job Trends"><br />
<img src="http://www.indeed.com/trendgraph/jobgraph.png?q=java%2C+ruby%2C+groovy%2C+skala" alt="java, ruby, groovy, skala Job Trends graph" border="0" height="300" width="540" /><br />
</a></p>
<table style="font-size: 80%" border="0" cellpadding="6" cellspacing="0" width="100%">
<tr>
<td><a href="http://www.indeed.com/jobtrends?q=java%2C+ruby%2C+groovy%2C+skala">java, ruby, groovy, skala Job Trends</a></td></p>
<td align="right"><a href="http://www.indeed.com/jobs?q=java">java jobs</a> - <a href="http://www.indeed.com/jobs?q=ruby">ruby jobs</a> - <a href="http://www.indeed.com/jobs?q=groovy">groovy jobs</a> - <a href="http://www.indeed.com/jobs?q=skala">skala jobs</a></td><br />
</tr><br />
</table><br />
3. Die aktuell diskutierten Sprachen bieten eine Menge tolle Werkzeuge um Komplexität in den Griff zu bekommen. ABER. Es sind Tools. Nicht mehr, nicht weniger. <a href="http://www.nealford.com/">Neal Ford</a> vergleicht Metaprogramming gerne mit medizinisch Opertationen. Ein wunderbarer Vergleich: Skalpelle sind toll und man kann da tolle Dinge mit dem menschlichen Körper tun. Aber ich möchte nicht, dass dies <a href="http://de.wikipedia.org/wiki/Jack_the_Ripper">irgendwer</a> tut, sondern <a href="http://de.wikipedia.org/wiki/Dr._House">jemand, der sich auskennt</a>. Und keins unserer Probleme wird einfach verschwinden, weil wir nicht mehr in Java programmieren. Wir brauchen immer noch die Experten, die sich einen Teil der Komplexität schnappen, und damit in den Tiefen einer Bibliothek verschwinden, damit wir diese Komplexität nie wieder sehen. Der Experte darf nach einiger Zeit wieder rauskommen.  :)<br />
4. Es stehen uns allen Interessante Zeiten bevor. Entscheidet selbst, ob ihr das im Sinne von <a href="http://www.amazon.de/gp/product/0061056901?ie=UTF8&amp;tag=schauderhafte-21&amp;linkCode=as2&amp;camp=1638&amp;creative=6742&amp;creativeASIN=0061056901">Terry Pretchet</a><img src="http://www.assoc-amazon.de/e/ir?t=schauderhafte-21&amp;l=as2&amp;o=3&amp;a=0061056901" style="border: medium none  ! important; margin: 0px ! important" border="0" height="1" width="1" /> versteht.</p>
