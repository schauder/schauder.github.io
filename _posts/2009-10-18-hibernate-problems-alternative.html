---
layout: post
status: publish
published: true
title: Hibernate has Problems, but where is the Alternative?
author:
  display_name: Jens Schauder
  login: admin
  email: jens@schauderhaft.de
  url: http://blog.schauderhaft.de
author_login: admin
author_email: jens@schauderhaft.de
author_url: http://blog.schauderhaft.de
wordpress_id: 294
wordpress_url: http://blog.schauderhaft.de/?p=294
date: '2009-10-18 19:30:55 +0200'
date_gmt: '2009-10-18 17:30:55 +0200'
categories:
- Softwaredevelopment
tags:
- hibernate
- orm
- future
comments:
- id: 281
  author: Emmanuel Bernard
  author_email: emmanuel@hibernate.org
  author_url: http://hibernate.org
  date: '2009-10-19 09:06:06 +0200'
  date_gmt: '2009-10-19 07:06:06 +0200'
  content: "Hello,\r\nAt least half of your points are already addressed:\r\n - check
    out Hibernate Validator and Bean Validation (JSR-303) for annotation based constraint
    declarations: they integrate with Hibernate already\r\n - I am not sure what you
    mean by big reference and adjusting the SQL. There is a bunch of annotations to
    adjust the SQL already (for example @Fetch)\r\n - the Session lifecycle is already
    managed in EJB 3 and in an even better way in JBoss Seam. I don't open &#47; close
    my sessions anymore and with Seam I don't have LIE\r\n - certainly JDBC could
    evolve to allow multi selects etc, but I doubt that will make things significantly
    better. Let's see if someone comes with a  good idea :)\r\n - There has been several
    prototypes using AOP to monitor and self adjust ORM configs but none have been
    taken seriously by application developers so far. Either they are not mature enough
    or people don't trust &#47; like them and prefer the manual approach."
- id: 282
  author: Dimitris
  author_email: dimitrisfx@yahoo.gr
  author_url: ''
  date: '2009-10-19 14:53:07 +0200'
  date_gmt: '2009-10-19 12:53:07 +0200'
  content: "\"Annotations feel like dirt in your code, and maintaining XML mappings
    is just painful.\"\r\n\"The problem with annotations is: they don&acirc;&euro;&trade;t
    belong in the business domain, where your classes live.\"\r\n\r\nI had the same
    concerns, however I found a solution. I am using the JPA API but I still keep
    using xdoclet to automatically generate xml mappings! The downside is that meta
    data kept in Hibernate proprietary form."
- id: 283
  author: igor
  author_email: igor.spasic@gmail.com
  author_url: ''
  date: '2009-10-20 09:14:00 +0200'
  date_gmt: '2009-10-20 07:14:00 +0200'
  content: 'There are always lightweight solutions: http:&#47;&#47;jodd.org&#47;doc&#47;db&#47;index.html'
- id: 284
  author: javaguy
  author_email: javaguy44@yahoo.com
  author_url: ''
  date: '2009-10-20 10:00:27 +0200'
  date_gmt: '2009-10-20 08:00:27 +0200'
  content: "ibatis\r\n - dead simple\r\n - ibator to gen your persistence domain pojos
    and daos\r\n - 1 jar"
- id: 285
  author: stanasic
  author_email: stanasic@gmail.com
  author_url: ''
  date: '2009-10-20 10:29:35 +0200'
  date_gmt: '2009-10-20 08:29:35 +0200'
  content: "I am by no means a Hibernate fan boy, but those points in which you agree
    with Stephen are pretty weak in my opinion. Let me clarify:\r\n\r\n<cite>\r\n-
    The SQL generated by Hibernate by default is horrible. Huge joins, with hundreds
    of columns, many unneeded.\r\n<&#47;cite>\r\n\r\nI think most of the SQL Hibernate
    generates is fine. In most of the cases, even if it appears bulky, there is no
    performance hit when it is actually executed by database. If you feel you're selecting
    more columns than you need,  maybe you need more fine-grained objects in your
    domain model. If there are too many joins, you are probably using too much EAGER
    fetching.\r\n\r\nFurthermore, you can use custom (native) SQL and still populate
    the domain objects, if you feel like it.\r\n\r\n<cite>\r\n- Annotations feel like
    dirt in your code, and maintaining XML mappings is just painful.\r\n<&#47;cite>\r\n\r\nThis
    is <b>extremely<&#47;b> subjective. I like having annotations in domain classes,
    since persistence is a key feature of those objects. You can minimize the amount
    of them by using proper NamingStrategy, so Hibernate can deduce column, table,
    foreign key names without you specifying them directly.\r\n\r\nAnd the cost of
    maintaining XML mappings has been blown way out of proportion. Some of the info
    contained therein can be deduced either from Java side or from the database, but
    still, how often do you refactor your domain classes and&#47;or database from
    the ground up? Someone without prior exposure to Hibernate would think there is
    some kind of magic involved with mapping files, but, in reality, they are quite
    readable and editable.\r\n\r\n<cite>\r\n- LazyInitializationExceptions are a pain
    in the a.. neck.\r\n<&#47;cite>\r\n\r\nThey are no more pain in the neck than,
    say, NullPonterExceptions. They simply signify the data you ask has not been loaded
    from database. What would you expect Hibernate to do. If the data is not there,
    you can either:\r\n\r\n1) make sure you fetch it, before you operate on it\r\n2)
    leave the session open, so Hibernate will do that for you (say, by means of OpenSessionInViewFilter)\r\n\r\nLastly,
    I wholeheartedly agree with your last paragraph."
- id: 287
  author: Paul
  author_email: ujoframework@gmail.com
  author_url: http://ujoframework.org/orm/
  date: '2009-10-20 13:14:55 +0200'
  date_gmt: '2009-10-20 11:14:55 +0200'
  content: "Another lightweight solution: \r\n <a href=\"http:&#47;&#47;ujoframework.org&#47;presentation&#47;\"
    title=\"Ujorm\" rel=\"nofollow\">http:&#47;&#47;ujoframework.org&#47;presentation&#47;<&#47;a>"
- id: 288
  author: Sanne
  author_email: sanne.grinovero@gmail.com
  author_url: ''
  date: '2009-10-20 23:02:41 +0200'
  date_gmt: '2009-10-20 21:02:41 +0200'
  content: "as Emmanuel said already, no more lazy initializations using the proper
    framework; If I see one, I know someone is doing dirty code or the configuration
    is wrong.\r\nI'd add that also the Sessions are now declaratively scoped, it really
    comes up in updating the frameworks people are using.\r\nAbout \"1:M relation
    is &acirc;&euro;&tilde;big&acirc;&euro;&trade;.\" that's also a thing from the
    past, you can get the behaviour you want, annotating properly. Sure, as a developer
    you have to know what you're asking for.\r\n\r\nAbout the generated SQL, I might
    be not a DB expert but I've learnt a lot from the generated SQL, when you test
    it out it's often better than what I would have written. That doesn't mean it's
    approaching perfection, but is far from wrong and much better than the average
    developer.\r\n\r\nI really agree with the conclusion; it's since 3 years know
    that I lead succesfull project in which the goal is to create a good domain model
    first, and then have Hibernate generate an appropriate schema. If the schema doesn't
    look right, we go back to the model and see what we are doing wrong. It's more
    a kind of feedback&#47;validation than the starting point. So definitely Hibernate
    is maturing, even if many new features are coming, but most people can't - or
    don't want - get the best out of it.\r\n\r\nbtw, I've experienced ibatis: it might
    be simple, but far from the usefulness, too much work to get stuff working.\r\n\r\nAnnotations
    might not be heaven, but are by far the most practical option available."
- id: 289
  author: Jens Schauder
  author_email: jens.schauder@lineas.de
  author_url: http://blog.schauderhaft.de
  date: '2009-10-20 23:55:14 +0200'
  date_gmt: '2009-10-20 21:55:14 +0200'
  content: "Thanks everybody for the comments. (and for the votes on dzone)\r\n\r\nA
    couple of comments to various points:\r\n\r\n- I know how to get hibernate the
    Eager&#47;Lazy loading I need. What I complain about is that in doing so, I annotate
    domain model with stuff that really belongs in the persistence layer.\r\n\r\n-
    Lazy Initialization Exception: You are probably right about the frameworks. I
    used Hibernate in a two tier application. Session handling is much less explored
    in <a href=\"&#47;2007&#47;12&#47;17&#47;hibernate-sessions-in-fat-client-anwendungen&#47;\"
    \ rel=\"nofollow\">this case<&#47;a >\r\n\r\n- I don't think persistence annotations
    on domain classes are a 'subjective' matter. But I do agree that they are better
    then XML. And I only have a rough idea, how it could be done in a <a href=\"&#47;2009&#47;08&#47;16&#47;high-level-frameworks&#47;\"
    \ rel=\"nofollow\">cleaner way<&#47;a>.\r\n\r\n- I looked at some of the simpler
    frameworks like ibatis. Its not a direction I want to go.\r\n\r\nAnd since I get
    the feeling at some got it the other way round: I do like hibernate and will probably
    use it in the next projects. But I do see room for improvement. Would be strange
    otherwise, wouldn't it?"
- id: 290
  author: Vic
  author_email: vcekvenich2@gmail.com
  author_url: ''
  date: '2009-10-21 05:06:36 +0200'
  date_gmt: '2009-10-21 03:06:36 +0200'
  content: Apache iBatis.
- id: 292
  author: Blog harvest, October II &laquo; Schneide Blog
  author_email: ''
  author_url: http://schneide.wordpress.com/2009/10/25/blog-harvest-october-ii/
  date: '2009-10-25 21:22:02 +0100'
  date_gmt: '2009-10-25 19:22:02 +0100'
  content: "[...] ORMs are a thing of the past &#8211; Another opinion that might
    get in the way of hibernate fanboys. We&#8217;ve had our share of hibernate &#8220;experiences&#8221;.
    It&#8217;s a useful tool if you know how to use it &#8211; and when not to. Replies
    followed instantly, here are two noteworthy ones by Scot Mcphee and by Jens Schauder.
    [...]"
- id: 296
  author: Rob Bygrave
  author_email: robin.bygrave@gmail.com
  author_url: http://www.avaje.org
  date: '2009-10-29 12:57:52 +0100'
  date_gmt: '2009-10-29 10:57:52 +0100'
  content: "Some of these points you have raised have already been addressed in existing
    ORM's like Ebean ORM. (http:&#47;&#47;www.avaje.org)\r\n\r\n\r\n- LazyInitializationExceptions
    \r\n---------------------------------------\r\nOther ORM's including Ebean ORM
    don't throw a LazyInitializationExceptions. That's a Hibernate specific approach.\r\n\r\n\r\n-
    The management of Sessions ...\r\n--------------------------------------------\r\nSome
    ORM's are design&#47;architected to be \"session less\". \r\n\r\nEbean ORM for
    example doesn't have an object equivilent to the Hibernate session or JPA EntityManager.
    Another way of saying this is that Ebean ORM provides \"automatic management of
    the persistence context\" - which is what you seemed to alude to. \r\n\r\nAs you
    probably know, the point of that is to remove the need to manage the \"session\"
    objects which makes life easier much for the developer.\r\n\r\nAka ORM session
    objects (like Hibernate Session &#47; JPA EntityManager) are an architectural
    design decision and not required&#47;used by some existing ORM's today. \r\n\r\n\r\n\r\n-
    ORMs will monitor how they are used for a certain application, and will use that
    information to improve the SQL used.\r\n--------------------------------------------------------\r\n\"Autofetch\"
    defines exactly this behaviour. The application is profiled and from this information
    the ORM can automatically tune the queries fetching only the properties required.
    \ \r\n\r\nEbean ORM has had this feature for about 1 1&#47;2 years. Works very
    nicely with Ebean's \"partial object\" support (which is mostly absent from JPA).\r\n\r\nRefer
    to: \r\nhttp:&#47;&#47;www.cs.utexas.edu&#47;~aibrahim&#47;autofetch&#47;\r\nhttp:&#47;&#47;www.avaje.org&#47;autofetch.html"
- id: 4345
  author: Toby
  author_email: superoverdrive@gmx.de
  author_url: http://www.flirtbox.co.uk
  date: '2011-10-05 10:36:06 +0200'
  date_gmt: '2011-10-05 08:36:06 +0200'
  content: "The idea of Hibernate was a framework that saves time and has a good performance.\r\n\r\nThe
    problem is:\r\n\r\n- You spend more time on it then you save:\r\n\r\n(a) learning
    it - not just by a few examples but you need to know ALL the details and philosophy\r\n(b)
    getting it to work\r\n(c) optimize it\r\n\r\n- it is not fast by default:\r\n\r\n(a)
    you need to know what you are doing\r\n(b) most people are not Hibernate experts
    \r\n(c) not only Hibernate queries and the Hibernate model needs to be exactly
    right, also the numerous parameters&#47;properties and also your application code
    that deals with the sessions etc...last but not least the Caching needs to be
    tuned.\r\n\r\nWhile a PHP developer with plain MySQL queries has finished his
    job for a long time - all the Java developers using Hibernate are still reading
    the documentation."
- id: 4346
  author: Jens Schauder
  author_email: jens@schauderhaft.de
  author_url: http://blog.schauderhaft.de
  date: '2011-10-05 13:01:54 +0200'
  date_gmt: '2011-10-05 11:01:54 +0200'
  content: "@Toby I actually somewhat agree by now. Maybe it's time for another hibernate
    article on this blog."
- id: 5079
  author: Alvin Allegrini
  author_email: Kuchar15@yahoo.com
  author_url: http://perfect-trader.com/index.php?format=feed&amp;type=rss
  date: '2012-02-20 11:13:32 +0100'
  date_gmt: '2012-02-20 09:13:32 +0100'
  content: What a wonderful invention of the mankind.
- id: 5696
  author: Igor Polevoy
  author_email: igor@polevoy.org
  author_url: http://code.google.com/p/activejdbc/
  date: '2012-04-07 23:45:13 +0200'
  date_gmt: '2012-04-07 21:45:13 +0200'
  content: "I had similar feelings about Hibernate for years, until I learned Ruby
    on Rails, and ActiveRecord implementation there was so elegant, that I decided
    to bring the same level of simplicity to Java. I started working on <a href=\"http:&#47;&#47;code.google.com&#47;p&#47;activejdbc&#47;\"
    rel=\"nofollow\">ActiveJDBC<&#47;a> in  2009, and released it in 2010. I tried
    to make it as lightweight, thin, fast and easy to use as possible. It requires
    no configurations, annotations XML or property files, yet just works. \r\n\r\nI
    agree with @Toby when it comes to Hibernate, but I have been using ActiveJDBC
    on all my projects since 2009, and I must say that I have a similar experience
    with a PHP or Rails developer."
- id: 10255
  author: Lukas Eder
  author_email: lukas.eder@datageekery.com
  author_url: http://www.hibernate-alternative.com
  date: '2013-09-06 16:28:10 +0200'
  date_gmt: '2013-09-06 14:28:10 +0200'
  content: "ORMs indeed take away the pain of writing repetitive CRUD. But not everyone
    things that the database belongs to the back. In many projects, the database *should*
    come first. There is an alternative to Hibernate in those scenarios:\r\n\r\nhttp:&#47;&#47;www.hibernate-alternative.com"
---
<p>[caption id="attachment_296" align="alignleft" width="300" caption="Scale"]<img class="size-medium wp-image-296" title="875413_47541979" src="http:&#47;&#47;blog.schauderhaft.de&#47;wp-content&#47;uploads&#47;2009&#47;10&#47;875413_47541979-300x203.jpg" alt="875413_47541979" width="300" height="203" &#47;>[&#47;caption]</p>
<p>In a late blog post Stephan Schmidt vents his problems with hibernate and declares "<a href="http:&#47;&#47;codemonkeyism.com&#47;orms&#47;">ORMs are a thing of the past<&#47;a>"</p>
<p>I agree to some extend:<br />
- The SQL generated by Hibernate by default is horrible. Huge joins, with hundreds of columns, many unneeded.<br />
- Annotations feel like dirt in your code, and maintaining XML mappings is just painful.<br />
- LazyInitializationExceptions are a pain in the <span style="text-decoration: line-through;">a..<&#47;span> neck.</p>
<p>But does that justify the conclusion, that ORMs will go away in the near future? I don't think so. Of course my <a href="http:&#47;&#47;blog.schauderhaft.de&#47;2009&#47;09&#47;20&#47;your-perspective-is-biased&#47;">perspective is biased<&#47;a>, but in the applications I build I deal typically with 200-500 tables. Just typing the basic CRUD Statement, and wrapping them into usable objects is a pain, and a lot of work, which I gladly will hand over to an ORM.</p>
<p>Tracking changes in objects is another task, I gladly handover to an ORM.</p>
<p>Even writing annotations, while being far from perfect is better then most alternatives I know.</p>
<p>Implementing my own caching logic? No thanx. The ORM can do that pretty well.</p>
<p>I think the crucial point lies in Stephans last paragraph, where he sketches some ideas for alternatives. ORMs aren't bad in themselves. They are just difficult to get right. Hibernate did a great job. It is the first one to get wide spread usage. And most points mentioned above are a weakness in Hibernate (or JPA) or possibly Java. So my claim is: ORMs aren't dead, they aren't even grown up.</p>
<p>So what properties might a grown up ORM have?</p>
<ul>
<li>Usage of persistence independent annotations: The problem with annotations is: they don't belong in the business domain, where your classes live. They are part of the persistence layer, and should stay there. But when you look at the JPA annotations you'll find a lot that is pretty usefull in GUI context as well. For example the length of a field isn't only important for the database but for the GUI as well. Same for validations. So I'd think, in a couple years from now we'll have annotations (or other language features), that let us specify features of properties and references, which truely live in the domain world. And the ORMs will just utilize that information for 90% of their needs<&#47;li>
<li>When the references will have more information attached to them. E.g. if it is just a association, or an aggregation, or if the M in an 1:M relation is 'big'. And ORMs will use that to optimize there SQL.<&#47;li>
<li>The management of Sessions will move toward a declarative style, just as transactions did in the last decade.<&#47;li>
<li> RDBMS vendors will finally realize the power of ORMs, and will provide more efficient protocols for the ORMs to communicate with.<&#47;li>
<li> ORMs will monitor how they are used for a certain application, and will use that information to improve the SQL used.<&#47;li><br />
<&#47;ul><br />
But as so often, the most important change will be a people change: People will finally let databases drop into the background where they belong, and manage the schema through the ORM. I always wonder "Why?" when I hear people describe how the build a database first, and then map classes to the tables. That is the wrong way around: Build a strong domain model first. Let the ORM create a database schema for you from that. And then get someone with strong database knowledge involved to tweak it where necessary. This is when you start seriously gaining something for your struggle with the ORM. Most importantly: you get strong support for database refactorings.</p>
<p>If you want to read more about the whole ORM discussion, you might be interested in this article by <a href="http:&#47;&#47;debasishg.blogspot.com&#47;2009&#47;10&#47;are-orms-really-thing-of-past.html">Debasish Ghosh<&#47;a>.</p>
