---
layout: default
status: publish
published: true
title: More on JUnit Theories
author:
  display_name: Jens Schauder
  login: admin
  email: jens@schauderhaft.de
  url: http://blog.schauderhaft.de
author_login: admin
author_email: jens@schauderhaft.de
author_url: http://blog.schauderhaft.de
wordpress_id: 404
wordpress_url: http://blog.schauderhaft.de/?p=404
date: '2010-02-07 15:02:21 +0100'
date_gmt: '2010-02-07 13:02:21 +0100'
categories:
- article
- Softwaredevelopment
tags:
- testing
- Java
- theory
comments:
- id: 367
  author: Jens Schauder
  author_email: jens.schauder@lineas.de
  author_url: http://blog.schauderhaft.de
  date: '2010-02-07 15:06:28 +0100'
  date_gmt: '2010-02-07 13:06:28 +0100'
  content: 'Looks like the bug I mentioned above is already reported: http:&#47;&#47;github.com&#47;KentBeck&#47;junit&#47;issuesearch?state=open&q=%40datapoints#issue&#47;55'
- id: 368
  author: Tweets die Schauderhaft &Acirc;&raquo; More on JUnit Theories erw&Atilde;&curren;hnt
    -- Topsy.com
  author_email: ''
  author_url: http://topsy.com/tb/blog.schauderhaft.de/2010/02/07/junit-theories/
  date: '2010-02-08 21:04:17 +0100'
  date_gmt: '2010-02-08 19:04:17 +0100'
  content: "[...] Dieser Eintrag wurde auf Twitter von Jens Schauder, Martin Veska
    erw&Atilde;&curren;hnt. Martin Veska sagte: JUnit Theories, experimental extension
    of popular framework. Looks interesting, more on http:&#47;&#47;bit.ly&#47;aGyC4i.
    [...]"
- id: 370
  author: SM
  author_email: smigl-200@yandex.ru
  author_url: http://night-fairy-tales.com/
  date: '2010-02-09 09:50:05 +0100'
  date_gmt: '2010-02-09 07:50:05 +0100'
  content: Intresting post. Thanks
- id: 385
  author: Outrospective.org &raquo; Blog Archive &raquo; Junit&#8217;s Theory&#8217;s
    as interprested by Schauderhaft and Groovy
  author_email: ''
  author_url: http://outrospective.org/wordpress/?p=283
  date: '2010-02-18 09:29:42 +0100'
  date_gmt: '2010-02-18 07:29:42 +0100'
  content: "[...] blog provides a great summary of what theories are and how to write
    a parameter supplier to supply a series of datapoints in Java. The annotation
    based ParameterSupplier does look a little verbose but as Schauderhaft [...]"
- id: 387
  author: Shin Hwei Tan
  author_email: shinhwei@hotmail.com
  author_url: ''
  date: '2010-02-18 14:06:42 +0100'
  date_gmt: '2010-02-18 12:06:42 +0100'
  content: Hi, I am the one who submitted the bug reports on github. If you agree
    with the bug regarding the array matching for DataPoints, please take some time
    to vote for the bug. Thanks.
- id: 388
  author: Jens Schauder
  author_email: jens.schauder@lineas.de
  author_url: http://blog.schauderhaft.de
  date: '2010-02-19 00:12:47 +0100'
  date_gmt: '2010-02-18 22:12:47 +0100'
  content: I tried to vote ... but it doesn't seem to take my vote :-(
- id: 405
  author: Mathilde Lem&Atilde;&copy;e
  author_email: mathilde.lemee@yahoo.fr
  author_url: http://www.java-freelance.fr
  date: '2010-03-17 16:56:34 +0100'
  date_gmt: '2010-03-17 14:56:34 +0100'
  content: Really useful !
- id: 4261
  author: 'Link: Advanced Usage of JUnit Theories, Multiple DataPoints, and ParameterSuppliers
    &laquo; The Holy Java'
  author_email: ''
  author_url: http://theholyjava.wordpress.com/2011/09/16/link-advanced-usage-of-junit-theories-multiple-datapoints-and-parametersuppliers/
  date: '2011-09-16 09:36:44 +0200'
  date_gmt: '2011-09-16 07:36:44 +0200'
  content: "[...] usually we have to rely on Jens Schauder&#8217;s blog and I&#8217;d
    like to draw your attention to his post describing advanced usage of JUnit Theories
    including things [...]"
- id: 4818
  author: flash42
  author_email: flash42@gmail.com
  author_url: ''
  date: '2012-01-17 18:50:47 +0100'
  date_gmt: '2012-01-17 16:50:47 +0100'
  content: "Hi!\r\n\r\nI've just tried thist out. One thing is sure, that it slows
    down the unit test performance a bit!\r\n\r\ncheers Adam."
- id: 4819
  author: Jens Schauder
  author_email: jens@schauderhaft.de
  author_url: http://blog.schauderhaft.de
  date: '2012-01-17 18:57:56 +0100'
  date_gmt: '2012-01-17 16:57:56 +0100'
  content: "@Adam thats an interesting piece of information. I never worried about
    this, because I normally have a few slow tests, that dominate the performance
    of my test suite."
- id: 6120
  author: Twaldigas
  author_email: fsommerfeldt@googlemail.com
  author_url: ''
  date: '2012-04-26 16:32:00 +0200'
  date_gmt: '2012-04-26 14:32:00 +0200'
  content: "Thanks for the nice tutorial. The last hours I try some nice things and
    now I have a issue. I want run my theories in parallel, but I don't know how.
    \r\n\r\nI can run parametrized tests in parallel, but theories not. Have you a
    idea, how it works?\r\n\r\nThank you very much and sorry for my bad english. ^-^
    I can read and understand it, but not write.\r\n\r\nBest regards,\r\nTwaldigas"
- id: 6138
  author: Jens Schauder
  author_email: jens@schauderhaft.de
  author_url: http://blog.schauderhaft.de
  date: '2012-04-26 23:15:47 +0200'
  date_gmt: '2012-04-26 21:15:47 +0200'
  content: "Hi Twaldigas,\r\nsorry no idea how to do that. I'd ask on stackoverflow
    or on the junit mailing list."
- id: 9200
  author: JUnit and Other Beasts, Part 4 | Softwire | Exceptional Bespoke Software
    Solutions and Consultancy
  author_email: ''
  author_url: http://www.softwire.com/blog/2012/06/22/junit-and-other-beasts-part-4/
  date: '2013-01-16 12:42:04 +0100'
  date_gmt: '2013-01-16 10:42:04 +0100'
  content: "[...] example of how to use ParameterSuppliers, and another with a fairly
    detailed real-world [...]"
---
<p>In my last <a href="&#47;2010&#47;01&#47;31&#47;new-feature-of-junit-theories&#47;">blog post<&#47;a>, I described how to use JUnit Theories to create large amounts of test runs, with very limited amount of work, like so:</p>
<pre lang="java">import static org.junit.Assume.assumeTrue;<br />
@RunWith(Theories.class)<br />
public class TheorieTest {</p>
<p>	@DataPoint<br />
	public static String a = "a";</p>
<p>	@DataPoint<br />
	public static String b = "bb";</p>
<p>	@DataPoint<br />
	public static String c = "ccc";</p>
<p>	@Theory<br />
	public void stringTest(String x, String y) {<br />
		assumeTrue(x.length() > 1);</p>
<p>		System.out.println(x + " " + y);<br />
	}<br />
}<&#47;pre><br />
The trick is simple to provide data points for every parameter type of the test method. The JUnit Theories Runner will call the test method with every possible combination of datapoints. If you think a little about it you will soon realize some of the limitations of this approach:</p>
<ul>
<li>You'll soon end up with lots of data point fields cluttering your code<&#47;li>
<li>Parameters of the same type will receive the same set of parameters, even when the usable range of inputs is completely different.<&#47;li><br />
<&#47;ul><br />
Fortunately the developers of JUnit provided really nice solutions to these problems.</p>
<p>Instead of specifying single data points, you can provide a full array of datapoints using the <tt>@Datapoints<&#47;tt> annotation, like so (add imports for good measure):</p>
<pre lang="java">@RunWith(Theories.class)<br />
public class TheorieTest {</p>
<p>	@DataPoints<br />
	public static String[] a = { "a", "bb", "ccc" };</p>
<p>	@DataPoints<br />
	public static Integer[] j = { 1, 2, 3 };</p>
<p>	@Theory<br />
	public void someTest(String x, Integer y) {<br />
		assumeTrue(x.length() > 1);</p>
<p>		System.out.println(x + " " + y);<br />
	}<br />
}<br />
<&#47;pre><br />
This of course is much less verbose. Instead of an array you may provide a method returning an array, or at least it looks like this should be possible. But when I tried it JUnit seemed unable to handle the types correctly resulting in IllegalArgumentExceptions. Guess I'll have to file a bug when finished with this article ...</p>
<p>But we still need to take care of parameters which have the same type, but very different meaning and therefore different useful values. The clean OO way of doing things would be to get rid of the generic types like <tt>String<&#47;tt> and use stronger types like <tt>CreditCardNumber<&#47;tt> or <tt>Name<&#47;tt> instead. But then in a perfect world we wouldn't need tests, because our programs wouldn't contain any bugs to begin with. So lets try this instead (Again imports omitted):</p>
<pre lang="java">@Retention(RetentionPolicy.RUNTIME)<br />
@ParametersSuppliedBy(CreditCardSupplier.class)<br />
public @interface AllCreditCards {}</p>
<p>&#47;&#47;-----------------------------------------------------------------</p>
<p>@Retention(RetentionPolicy.RUNTIME)<br />
@ParametersSuppliedBy(NameSupplier.class)<br />
public @interface AllNames {}</p>
<p>&#47;&#47;-----------------------------------------------------------------</p>
<p>public class CreditCardSupplier extends ParameterSupplier {</p>
<p>	@Override<br />
	public List getValueSources(<br />
			ParameterSignature signature) {</p>
<p>		ArrayList result = new ArrayList();</p>
<p>		result.add(PotentialAssignment.forValue("Amex", "Amex"));<br />
		result.add(PotentialAssignment.forValue("Master", "Master"));<br />
		result.add(PotentialAssignment.forValue("Visa", "Visa"));</p>
<p>		return result;<br />
	}<br />
}</p>
<p>&#47;&#47;-----------------------------------------------------------------</p>
<p>public class NameSupplier extends ParameterSupplier {</p>
<p>	@Override<br />
	public List getValueSources(<br />
			ParameterSignature signature) {</p>
<p>		AllNames annotation = signature.getAnnotation(AllNames.class);<br />
		System.out.println("just wanted to show that I can access it "<br />
				+ annotation);</p>
<p>		ArrayList result = new ArrayList();</p>
<p>		result.add(PotentialAssignment.forValue("Alf", "Alf"));<br />
		result.add(PotentialAssignment.forValue("Willie", "Willie"));<br />
		result.add(PotentialAssignment.forValue("Tanner", "Tanner"));<br />
		result.add(PotentialAssignment.forValue("Cat", "Cat"));</p>
<p>		return result;<br />
	}<br />
}</p>
<p>&#47;&#47;-----------------------------------------------------------------</p>
<p>@RunWith(Theories.class)<br />
public class SuppliedByTest {</p>
<p>	@Theory<br />
	public void imagineThisIsATest(@AllCreditCards String x, @AllNames String y) {<br />
		System.out.println("consider " + x + " &#47; " + y + " tested.");<br />
	}</p>
<p>	@Theory<br />
	public void testIntegers(@TestedOn(ints = { 2, 3, 4, 7, 13, 23, 42 }) int i) {<br />
		System.out.println(i);<br />
	}<br />
}<br />
<&#47;pre><br />
Wow, thats a lot of code. Just look at the last piece and see what appears in the console when we run it:</p>
<pre>just wanted to show that I can access it @de.schauderhaft.junit.theories.AllNames()<br />
consider Amex &#47; Alf tested.<br />
consider Amex &#47; Willie tested.<br />
consider Amex &#47; Tanner tested.<br />
consider Amex &#47; Cat tested.<br />
just wanted to show that I can access it @de.schauderhaft.junit.theories.AllNames()<br />
consider Master &#47; Alf tested.<br />
consider Master &#47; Willie tested.<br />
consider Master &#47; Tanner tested.<br />
consider Master &#47; Cat tested.<br />
just wanted to show that I can access it @de.schauderhaft.junit.theories.AllNames()<br />
consider Visa &#47; Alf tested.<br />
consider Visa &#47; Willie tested.<br />
consider Visa &#47; Tanner tested.<br />
consider Visa &#47; Cat tested.<br />
2<br />
3<br />
4<br />
7<br />
13<br />
23<br />
42<br />
<&#47;pre><br />
Have a look at the row beginning with: "consider". Obviously the Theory <tt>imagineThisIsATest<&#47;tt> gets fed with the values from the <tt>CreditCardSupplier<&#47;tt> and <tt>NameSupplier<&#47;tt>. The parameters and the 'Suppliers' are connected by the two annotations <tt>@AllNames<&#47;tt> and <tt>AllCreditCards<&#47;tt>. So whenever you have a parameter to a theory where the type alone is not sufficient for identifying the kind of values that should get used, you can simple create an annotation, which itself is annotated with a reference to a <tt>ParameterSupplier<&#47;tt> class and you are all set. You might think this is a lot of code for supplying a handful of parameters. You are right, but remember, that you can reuse your suppliers wherever you need names or credit card values in your tests.</p>
<p>Now let's look at the first line of the output:<br />
<tt>just wanted to show that I can access it @de.schauderhaft.junit.theories.AllNames()<&#47;tt><br />
It simply shows of that you get access to the annotation (and actually the signature of the compete test method. This can be very useful, when you want your supplier to behave differently for different theories. Have a look at the <tt>NameSupplier<&#47;tt> above to see how this works.</p>
<p>JUnit actually comes with an example where this is used, and I demonstrated it with the other theory in the demonstration code above. The <tt>@TestedOn<&#47;tt> annotation takes an array of values to be used as data points for the annotated parameter.</p>
<p>Thats it for today. I hope the power of theories became obvious, as well as the power you have as a developer to extend that mechanism. Again be warned: All this nice stuff is in a package named experimental for good reason. If you use it, you might find bugs, and thing will likely change at least in name in an upcoming version. Taking about versions, I am using junit4.8.1 for the examples.</p>
<p>For next week the conclusion of the little series about JUnit theories is planned, with a few thoughts on use and danger of this kind of testing.</p>
