---
layout: default
status: publish
published: true
title: Plans for My Next Project
author:
  display_name: Jens Schauder
  login: admin
  email: jens@schauderhaft.de
  url: http://blog.schauderhaft.de
author_login: admin
author_email: jens@schauderhaft.de
author_url: http://blog.schauderhaft.de
wordpress_id: 1096
wordpress_url: http://blog.schauderhaft.de/?p=1096
date: '2012-05-20 16:55:36 +0200'
date_gmt: '2012-05-20 14:55:36 +0200'
categories:
- article
- Softwaredevelopment
tags: []
comments:
- id: 6665
  author: Andreas
  author_email: andreas_schilling@gmx.net
  author_url: ''
  date: '2012-06-05 16:54:16 +0200'
  date_gmt: '2012-06-05 14:54:16 +0200'
  content: "I actually don't get what people dislike about the spring XML config :-)
    in all my projects so far we explicitely decided against annotation- or java-based
    configuration. I believe they are great for smaller projects but with our current
    large applications I really like how the spring config is in one specified place
    (in each bundle) where you have great overview over all your beans without having
    to filter out all the stuff around the relevant annotations or code pieces. But
    maybe it's also just a matter of getting used to it.\r\nApart from that: yes,
    really use DI. It's so much more fun working on the project! And if Spring is
    too heavy-weight try using Google Guice. Nowadays I consider it a general project
    smell if it is NOT based on DI :-)\r\n\r\nMy personal plans are:\r\n- base everything
    on Google Guava from the very beginning. Guava enables you to write so amazingly
    speaking, compact and GOOD code (if you do not abuse it, which is a definitive
    danger with it as well...), I'd like to dance in joy everyday\r\n- use more TDD
    :-)\r\n- bundles, bundles, bundles. Everything needs to be split into more bundles
    in our OSGi-projects (especially splitting basically every bundle in its implementation
    and interface parts). It's 2012, we have powerful IDEs. Big number of bundles
    is thus not an issue. It's alot easier to start searching for a package/class/functionality
    from a nicely structured top-level modularization than from one big bundle with
    a (possibly fucked up) complex package structure. Not to talk about reusing stuff
    within your company without having to import quadzillions of dependencies you
    do neither like nor want.\r\n- did I mention using MOAR Guava? :-)"
---
<p>About two years ago I made some <a href="/2010/01/10/new-projects-resolution/">plans for my next project</a>. My time on that project is almost over because I'm switching companies. So it is time to review those plans and make new plans for the next project.</p>
<p>Lets start with the review:</p>
<blockquote><p><strong>Earlier Tests</strong>&Acirc;&nbsp;&acirc;&euro;&ldquo; One reason we didn&acirc;&euro;&trade;t produce as many tests as I would wish today is that we didn&acirc;&euro;&trade;t do TDD. It probably was a correct decission the last time, since it would have been just to much. But this time I will practice TDD as good as I can.</blockquote><br />
We did lots of TDD in the project and I love it. Its great and although everybody is bitching about the code quality, I think we are way better of then most of the projects I have seen. After all this <a href="http://www.osnews.com/images/comics/wtfm.jpg">XKCD cartoon is still valid</a>. So this one is a keeper.</p>
<blockquote><p><strong>Cleaner Code</strong>&Acirc;&nbsp;&acirc;&euro;&ldquo; One of the first tests I wrote back then was a test to ensure that we don&acirc;&euro;&trade;t have circular dependencies. We succeeded in this, but still parts of the system a pretty tangled. We gonna improve that. Appart from the knowledge I took from&Acirc;&nbsp;<a href="http://www.amazon.com/gp/product/0132350882?ie=UTF8&amp;tag=schauderhaft-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0132350882">Clean Code</a>&Acirc;&nbsp;I&acirc;&euro;&trade;ll plan to use the&Acirc;&nbsp;<a href="http://erik.doernenburg.com/2008/11/how-toxic-is-your-code/">toxicity metric</a>&Acirc;&nbsp;as an important tool for that.</blockquote><br />
I spent quite some time trying to improve code, the ability of myself and coworkers to write clean code and that is certainly a good thing. Another keeper. As always there is still lots of room for improvement.</p>
<blockquote><p><strong>Dependency Injection</strong>&Acirc;&nbsp;&acirc;&euro;&ldquo; We considered using Spring and decided against it, because we already had about 20 libraries we hardly knew in the project. Again at that time it was a reasonable decision. But in the meantime I learned what we could have gained by using Spring. I&acirc;&euro;&trade;ll propose using it, but even when the team declines again, I&acirc;&euro;&trade;ll be able to use the concept in order to improve the code base.</blockquote><br />
I failed to make this one real. We had to use a framework which among other problems made it hard (impossible?) to use Spring or anything similar in one large part of the project. We used it a little on the back end, but probably had profited if we had used more features of it. But although we really had only a little Spring in our project I learned to hat its XML configuration. What a royal pain in the a***. But I here there are alternatives out there. We'll see.</p>
<p>So on average my resolution worked out well. I was able to follow through with them and it was to the advantage of the project.</p>
<p>So what will I try to improve on the next project?</p>
<p><strong>Less reflection</strong>: I really should have put that in the previous resolution. But sometimes it takes time to learn. Reflection is a powerful tool. But it has a tendency to point itself in the general direction of your feet. It breaks refactoring tools. It hides dependencies and after all in 9 out of 10 cases it is just a workaround for missing language features. I doubt I'll convince you with this statement if you aren't already convinced, but the explanation has to wait for another article.</p>
<p><strong>Cleaner Packages</strong>: As I have written before I think <a href="/2011/07/17/breaking-dependency-cylces/">cyclic dependencies on the package level are evil</a>. &Acirc;&nbsp;So early on I established a rule that disallowed cyclic dependencies on package level (and also set some other rules regarding package dependencies). The result: We ended up with a package with over 150 classes in it at some point. For about one third of it even my 7 year old son could have told you these classes where in the wrong package. The problem of course was that it was easier to put a class in the wrong package than figuring out how to structure code and packages in a way that made sense and was legal according to the rules. So I guess the next time I'll bring an extra test that checks for the size of the package oh and another check that keeps me informed when somebody changes the limits in these tests. But more important then the technical side is the fact that I'll have to teach why such rules makes sense and how one can obey them. Certainly a valuable lesson to learn.</p>
<p><strong>More Involvement in the Domain Side</strong>: One of the biggest problems we have in our current project is our lack of understanding what the user actually needs. We tried to get into contact with the user (which is a difficult thing in an organisation like the one hosting that project). But we largely failed for a long time. On the next project I'll make sure I'll meet the actual users. Lots of them. Often. &Acirc;&nbsp;And I will learn more about the domain. Promised.</p>
<p>So these are my plans. Obviously I don't know if they work out as planned. But I will try. What are your plans for the next project or the next 12 months in the same project? Where can YO'U improve?</p>
