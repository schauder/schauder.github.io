---
layout: default
status: publish
published: true
title: The Importance of Packages
author:
  display_name: Jens Schauder
  login: admin
  email: jens@schauderhaft.de
  url: http://blog.schauderhaft.de
author_login: admin
author_email: jens@schauderhaft.de
author_url: http://blog.schauderhaft.de
wordpress_id: 1269
wordpress_url: http://blog.schauderhaft.de/?p=1269
date: '2013-01-13 07:06:41 +0100'
date_gmt: '2013-01-13 05:06:41 +0100'
categories:
- article
- Softwaredevelopment
tags:
- Java
- structure
- modularity
- import
- namespace
comments:
- id: 9020
  author: myfear
  author_email: twitter.14206328@example.com
  author_url: http://twitter.com/myfear
  date: '2012-12-30 08:49:59 +0100'
  date_gmt: '2012-12-30 06:49:59 +0100'
  content: 'RT @jensschauder: I blogged: The Importance of Packages: I remember approximately
    15 years ago when I started learning Java. I read ...  ...'
- id: 9179
  author: Geek Reading January 14, 2013 | Regular Geek
  author_email: ''
  author_url: http://regulargeek.com/2013/01/14/geek-reading-january-14-2013/
  date: '2013-01-14 19:01:00 +0100'
  date_gmt: '2013-01-14 17:01:00 +0100'
  content: "[...] The Importance of Packages (Schauderhaft) [...]"
- id: 9183
  author: Cory Radcliff
  author_email: facebook.cory.radcliff@example.com
  author_url: http://facebook.com/profile.php?id=502643155
  date: '2013-01-15 00:04:16 +0100'
  date_gmt: '2013-01-14 22:04:16 +0100'
  content: "I've been reasonably happy with Maven's dependency management for Java.
    Wondering if there was a reason to not include it at the end of the article? Not
    that everything that manages dependencies is required, but it seems to be pretty
    standard. \r\n\r\nGreat article. Its really a helpful way to approach code organization."
- id: 9184
  author: Jens Th.
  author_email: jens.thielscher@gmail.com
  author_url: ''
  date: '2013-01-15 01:31:05 +0100'
  date_gmt: '2013-01-14 23:31:05 +0100'
  content: "Camel case in package names? I have never seen that in Java before.\r\n\r\n@Cory
    Radcliff: How do you manage package dependencies with maven? Ok, you can put each
    package in a separate maven module..."
- id: 9216
  author: adamwarski
  author_email: twitter.adamwarski@example.com
  author_url: http://twitter.com/adamwarski
  date: '2013-01-17 23:34:41 +0100'
  date_gmt: '2013-01-17 21:34:41 +0100'
  content: "For managing dependencies, like Cory mentioned, so far I mainly used build
    modules; but that quickly becomes a pain. I looked at tools like JDepend, but
    what I didn't like too much there is that the dependencies aren't expressed in
    the code, but in a separate file, which can get hard to manage as well.\r\n\r\nSo
    I started on my own tool (http://www.warski.org/blog/2013/01/veripacks-0-1-verify-package-specifications/),
    where you can annotate a class (or a couple of classes), and then only this class
    will be visible outside the whole package tree. Not sure yet how it will evolve,
    though :)"
- id: 9699
  author: How to replace a build module with Veripacks | Blog of Adam Warski
  author_email: ''
  author_url: http://www.warski.org/blog/2013/03/how-to-replace-a-build-module-with-veripacks/
  date: '2013-03-26 22:55:52 +0100'
  date_gmt: '2013-03-26 20:55:52 +0100'
  content: "[...] build module. Each application module now corresponds to one top-level
    project package (see also this blog on package naming [...]"
- id: 388159
  author: Softwre Architecture Bookmarks &#8211; Programming
  author_email: ''
  author_url: https://davidlisg.wordpress.com/2015/03/27/softwre-architecture-bookmarks/
  date: '2015-03-27 11:21:35 +0100'
  date_gmt: '2015-03-27 09:21:35 +0100'
  content: "[&#8230;] Jens Schauder [2013-01-13] The Importance Of Packages http://blog.schauderhaft.de/2013/01/13/the-importance-of-packages/
    [&#8230;]"
- id: 405052
  author: Thoughts about architecture | info.michael-simons.eu
  author_email: ''
  author_url: http://info.michael-simons.eu/2015/09/23/thoughts-about-architecture/
  date: '2015-09-23 13:58:47 +0200'
  date_gmt: '2015-09-23 11:58:47 +0200'
  content: "[&#8230;] implement that pattern. @jensschauder has written much more
    eloquent than i about this here (Jens does also a pretty good talk about that
    topic and has some really nice drawings in it as [&#8230;]"
---
<p>I remember approximately 15 years ago when I started learning Java. I read a lot about this 'package' thing and 'namespaces' and I totally didn't get it.</p>
<p>Sad thing is: While some aspects of package are understood by pretty much everybody in the industry others aren't. So lets have a look what packages are good for.</p>
<p><strong>Namespaces</strong>: By prefixing all your packages with a domain you control, you make sure that your class names are unique. This is essential for the success of an unbelievable number of open source projects. Every project can (and probably does at some stage) define a 'Filter' class without having that class interfere with all the other classes of that same name (apart from the poor developer that copied some code without import statements from the web and now has to figure out which Filter class was actually referenced). This one is pretty well understood and I haven't seen any relevant usage of the root package in ages.</p>
<p><strong>Organization</strong>: My son has a huge box of Lego bricks. Probably multiple thousands maybe tens of thousands of them. When he looks for a simple 2x4 brick this is not a problem. But when he is searching for that special brick that only exists 4 times in the collection or even just once!? It might take a loooooong time to find it. Compare that to an apothecary cabinet. Hundreds of drugs and it normally takes only seconds to find the right one. And they don't even use Google for that! They just have a strict ordering principle where each drug belongs, including a rule how the right box for a new drug is determined. Since everybody involved knows that principle it is easy to determine the correct box where the drug is to be found. Such an ordering principle is tremendously helpful when established early in a project.</p>
<p>When defining such a principle one criteria isn't sufficient most of the time. But if you use more then one make sure they don't interfere, by making the rules orthogonal. This means don't have a rule saying: "All database access code has to go in package x" and another rule stating "All code related to customers has to go into package y". Otherwise you won't know where to put the CustomerDAO. Instead apply orthogonal rules on different depths of the package tree. My default package structure looks like this:</p>
<pre><organisational-prefix>.<application>.<deployment-unit>.<module>.<layer>.<br />
<optional further substructure if needed></pre><br />
This results in package names like</p>
<p><tt>com.mycompany.theCoolApp.server.user.persistence</tt></p>
<p>or</p>
<p><tt>com.mycompany.theCoolApp.client.shoppingCart.presentation</tt></p>
<p>If you look at a package structure like this, it becomes pretty obvious where a new class belongs, or where to look if something like this already exists. It gets even better when you avoid names like <tt>util</tt> or <tt>misc</tt> which can hide more or less everything. Also you can look at these packages and immediately learn something about the architecture. As soon as you see a level of packages named <tt>client</tt>, <tt>webserver</tt> and <tt>batchserver</tt> you'll form a model in your head how the application is structured and if the names are picked well it is probably close to the real thing. Since in each <tt>module</tt> the same rules for <tt>layers</tt> apply you can find out more about the structure of the application in the lower packages as well.</p>
<p>The <tt>module</tt>s in between communicate the kind of domain the application deals with. Quite naturally the important concepts get their own package and thereby make a statement to everyone inspecting the code: this is an important concept in this application.</p>
<p>I also like adding the rule "A package should contain <em><tt>a</tt>-<tt>b</tt></em> classes, but must not contain <em><tt>c</tt></em> or more" with appropriate values for a, b and c. This forces the creation of new packages as the application grows, keeping each package to a manageable size.</p>
<p>Of course on smaller applications the structure might get scaled down. For example if there is just one deployment unit there is no need for a separate package level for that classification.</p>
<p>The last usage for package is the most ignored: the <strong>intermediate modeling block</strong>: Joe Average Developer concerns herself mostly with classes and methods and single lines of code, while trying to come up with a code structure on that level that fits the needs of the application. Often there is some kind of architect who figures out how to deploy the application and thereby determines the necessary deployment units (think separate jars). If you look at the scale of these artifacts something interesting might catch your eye:</p>
<p>1 method consists of approximately 10 lines of code.</p>
<p>1 class consists of approximately 10 methods.</p>
<p>1 jar consists of approximately 100 - 1000 classes.</p>
<p>If nobody takes care of packages there is at least one, often two levels of structure missing! This gap can and should be filled with packages. This doesn't only mean the packages should exist and be of reasonable size, it also means they should adhere to common design guide lines. Especially <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a> and proper handling of dependencies:</p>
<p><strong>Single Responsibility Principle</strong> With the naming scheme proposed above, a lot of work toward honoring the SRP is done. If the contents of the package does what its name says everything is fine on that front.</p>
<p><strong>Managing of Dependencies</strong> is a tougher beast. Java currently doesn't offer a proper system to control dependencies between packages and especially super packages, i.e. packages that contain multiple other packages. There is <a href="http://en.wikipedia.org/wiki/OSGi">OSGI</a>, but I found it a pain in the neck to work with, especially since I never needed all the dynamic loading stuff but suffered from the resulting class loader issues. There is also <a href="http://openjdk.java.net/projects/jigsaw/">Jigsaw</a>&Acirc;&nbsp;but this is not there yet. Therefore I prefer homegrown tests for defining and verifying the package structure of applications I work with. My tool of choice is <a href="http://clarkware.com/software/JDepend.html">JDepend</a>. It gives you lists of dependencies between packages and you can use those to compare them to rules you define. Somebody creates a dependency from package A to package B that should not exist? Boom, the test turns red.</p>
<p>So what are useful rules for package dependencies? First: No cycles. Not on the package level, but also not on the <tt>layer</tt> level nor on the <tt>module</tt> level as used above. Second: Modules and Layers have a strict order in which they can depend on each other, everything else is forbidden.</p>
<p>These rules considerably limit the degrees of freedom one has as a developer. But in my experience it smokes out violations of the Single Responsibility Principle, which often surfaces as cyclic dependencies. For example if you have an Order module and a Customer module it feels like these two need to know each other. If you have an Order, you want to know the Customer it belongs to. If you have a Customer you must be able to tell her the Orders she placed. Right? Yes, probably. But do you need the full blown objects and functionality on both side? Probably not. By coming up with an interface package for example containing only the very core for the customer functionality needed by the Order module and and a separate full Customer module that has the references the orders <a href="/2011/07/17/breaking-dependency-cylces/">one can break these dependencies</a> AND achieve a stronger separation of concern in your package structure.</p>
<p>This in turn helps when you try to evolve your application. What today is a package might grow into a deployment-unit someday and if you have circular dependencies between deployment-units you'll have some serious problems. Or maybe your team grows into multiple teams. With a clean package structure as described above you have a obvious bounds where you can split and also an obvious criteria when the teams have to sit together to discuss changes on a package used by multiple teams.</p>
<p>Take care (of your package structure).</p>
