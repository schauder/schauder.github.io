<p>There is a<a href="&#47;2008&#47;09&#47;28&#47;hibernate-sessions-in-two-tier-rich-client-applications&#47;"> english version of the article<&#47;a> available.</p>
<p>Die meisten Teams setzen Hibernate f&Atilde;&frac14;r Webanwendungen ein. Schon allein, weil wesentlich mehr Webanwendungen erstellt werden, als klassische Client-Server-Systeme. Ich dagegen setze es zur Zeit in einer Swing basierten Zwei-Schichten-Architektur ein. In Webanwendung ist die Interaktion mit der Datenbank und Hibernate stark strukturiert: Der Server erh&Atilde;&curren;lt eine Anfrage, bearbeitet sie und liefert das Ergebnis in Form einer Webseite wieder zur&Atilde;&frac14;ck. F&Atilde;&frac14;r genau diesen Zeitraum wird in Webanwendungen eine <a href="http:&#47;&#47;www.hibernate.org&#47;hib_docs&#47;v3&#47;api&#47;org&#47;hibernate&#47;Session.html" title="Hibernate Session Javadoc">Hibernate Session<&#47;a> verwendet und die Hibernate Session ist so implementiert, dass genau dies <a href="http:&#47;&#47;www.hibernate.org&#47;42.html" title="Hibernate Artikel zu Session und Transactions">gut funktioniert<&#47;a>.</p>
<ul>
<li>Die Session repr&Atilde;&curren;sentiert eine 'Unit of Work', also eine Arbeitseinheit. Diese kann identisch mit einer Datenbanktransaktion sein, kann sich aber auch &Atilde;&frac14;ber mehrere Datenbanktransaktionen erstrecken.<&#47;li>
<li>Es ist eine Id-Map Jede Entit&Atilde;&curren;t gibt es in einer  Session nur einmal.<&#47;li>
<li>Eine Session ist ein First Level Cache f&Atilde;&frac14;r die Datenbank: Jede Entit&Atilde;&curren;t die in der Session verwendet wird, wird in der Session gehalten, bis die Session beendet wird.<&#47;li>
<li>Um Lazy Loading zu verwenden muss ein Objekt einer Session zugeordnet sein, und ein Objekt kann (im wesentlichen) nur einer Session zugeordnet sein.<&#47;li><br />
<&#47;ul><br />
Die 'Unit of Work' ist in Form eines Requests bei Webapplikationen einleuchtend und eindeutig identifizierbar, wie oben beschrieben.</p>
<p>In einer Zwei-Schichten-Architektur sieht die Welt jedoch anders aus. Zun&Atilde;&curren;chst einmal ist es verlockend, &Atilde;&curren;hnlich zu arbeiten, wie man es von JDBC Verbindungen gew&Atilde;&para;hnt ist: Man beginnt eine Session und arbeitet mit dieser Session bis zum Ende der Anwendung. Dies hat offensichtliche Vorteile: Die Id-Map stellt sicher, dass jede Entit&Atilde;&curren;t eindeutig in der JVM repr&Atilde;&curren;sentiert wird. Aktualisierung von GUI-Komponenten funktioniert dadurch praktisch von alleine. Aber es hat ebenso offensichtliche Nachteile. Durch das Caching in der Session, w&Atilde;&curren;chst die Session immer weiter an. Fr&Atilde;&frac14;her oder sp&Atilde;&curren;ter f&Atilde;&frac14;hrt dies unweigerlich zu Speicherproblemen. Es gibt Anwendungen, f&Atilde;&frac14;r die dies akzeptabel ist, viele Anwendungen ben&Atilde;&para;tigen aber ein anderes Konzept. Um ein solches Konzept zu entwickeln sollte man sich im klaren sein, was man eigentlich will.</p>
<p>F&Atilde;&frac14;r uns war dies:</p>
<ol>
<li>Lazy Loading muss funktionieren, da dies eins der Hauptargumente f&Atilde;&frac14;r, bzw. Vorteile von Hibernate sind, gegen&Atilde;&frac14;ber einer manuell implementierten Variante auf Basis von JDBC<&#47;li>
<li>Verschiedene Ansichten einer Entit&Atilde;&curren;t m&Atilde;&frac14;ssen synchron gehalten werden.<&#47;li>
<li>Das ganze muss muss halbwegs stabil und zuverl&Atilde;&curren;ssig sein, so dass auch Otto Normalentwickler damit umgehen kann.<&#47;li><br />
<&#47;ol><br />
Anforderung Nr.1 zwingt dazu, das jedes Objekt, welches aus der Datenbank geladen wird, in einer Session verbleibt. Um zu verhindern, dass wir Objekte auf ewig in einer Session sammeln, muss eine Session zu einem definierten Zustand wieder geschlossen werden, nat&Atilde;&frac14;rlich erst, wenn die enthaltenen Objekte nicht mehr verwendet werden.</p>
<p>Aber wo ist die Session (oder Unit of Work)? Man stellt sich etwas vor wie: Daten laden, Daten ver- bzw. bearbeiten, Daten speichern.</p>
<p>Wenn ich eine Liste von Personen anzeige, starte ich damit also wohl eine Session.</p>
<p>Wenn ich eine Person ausw&Atilde;&curren;hle, editiere und speichere, beende ich damit ein Session. Problem gel&Atilde;&para;st?  Mit nichten! Ich w&Atilde;&curren;hle ein zweite Person zur Bearbeitung aus und schon habe ich eine Session ge&Atilde;&para;ffnet, und zwei beendet?</p>
<p>Zu einem gegebenen Zeitpunkt kann es beliebig viele Dialoge oder Fenster in der Anwendung geben. Objekte werden per Drag'n'Drop von einem Fenster ins n&Atilde;&curren;chste gezogen. Alles kann zumindest prinzipiell mit allem interagieren. Wo ist da die Session?</p>
<p>Meine Antwort: Im wesentlichen hat jedes Fenster seine eigene Session, Modale Dialog verwenden die Session ihres &Atilde;&frac14;bergeordneten Fensters, Aktionen die im Hintergrund laufen haben ebenfalls ihre eigene Session. Wird das Fenster geschlossen, oder die Hintergrundaktion abgeschlossen, wird auch die Session geschlossen. Daher ist es wichtig, dass kein Objekt, dass in einem Fenster bearbeitet wird, den Einflussbereich dieses Fensters verl&Atilde;&curren;&Atilde;&Yuml;t.  Es w&Atilde;&frac14;rde ansonsten nicht mehr zu einer aktiven Session geh&Atilde;&para;ren und Lazy Loading w&Atilde;&frac14;rde nicht mehr funktionieren.</p>
<p>Wie kommen dann Objekte von einem Fenster ins n&Atilde;&curren;chste? Wie bei einer Webanwendung: Es wird die Id &Atilde;&frac14;bergeben und &Atilde;&frac14;ber Session.get() wird das Objekt neu geladen. Ein Second Level Cache  sorgt daf&Atilde;&frac14;r, dass dieses neu Laden nur dann auf die Datenbank trifft, wenn der urspr&Atilde;&frac14;ngliche Ladeprozess schon entsprechend lange her ist.</p>
<p>Bleibt die Frage, wie ich sicherstellen kann, dass keine veralteten Daten in einem Fenster dargestellt werden, obwohl sie in einem anderen Fenster der Anwendung schon in einer aktualisierten Form dargestellt sind. Dies kann durch erstaunlich wenig Aufwand bewerkstelligt werden. Mit einem Listener an postLoad, postUpdate und commit Events bekommen wir mit, wenn es neue Versionen einer Entit&Atilde;&curren;t in der Datenbank gibt. &Atilde;&oelig;ber Sessions.getSessionStatistics k&Atilde;&para;nnen wir herausfinden, welche Session welche dieser Entit&Atilde;&curren;ten ebenfalls beeinhaltet und k&Atilde;&para;nnen gegebenenfalls Session.refresh() aufrufen, um das Objekt zu aktualisieren. Dies sollte nat&Atilde;&frac14;rlich nur f&Atilde;&frac14;r Sessions geschehen, die nur f&Atilde;&frac14;r Lesezwecke verwendet werden, da der Benutzer wohl kaum begeistert ist, wenn w&Atilde;&curren;hrend er ein Objekt editiert, dies gerade mal unaufgefordert durch eine frische Version aus der Datenbank ersetzt wird.</p>
<p><strong>Andere Quellen zu diesem Thema (mit vielen verschiedenen Meinungen zum Thema):<&#47;strong></p>
<ul>
<li><a href="http:&#47;&#47;www.hibernate.org&#47;333.html" title="Best Practices for Thick-Client Applications (i.e., non-web apps.)">Hibernate Wiki Artikel + Diskussion<&#47;a><&#47;li>
<li><a href="http:&#47;&#47;lists.jboss.org&#47;pipermail&#47;hibernate-dev&#47;2006-September&#47;000374.html" title="[hibernate-dev] session-per-application in a rich client an antipattern?">Beitrag in hibernate-dev Mailingliste<&#47;a><&#47;li>
<li><a href="http:&#47;&#47;forum.hibernate.org&#47;viewtopic.php?t=965080" title="session-per-application in a rich client an antipattern?">Der selbe Fragensteller aber mehr Diskussiom im Forum<&#47;a><&#47;li>
<li><a href="http:&#47;&#47;forum.java.sun.com&#47;thread.jspa?threadID=700590&amp;start=0&amp;tstart=0" title="Java Programming - Is it Possible to Combine Hibernate + Swing?????">Diskussion im Sun Java Forum<&#47;a><&#47;li><br />
<&#47;ul></p>
