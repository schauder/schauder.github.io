<p>In dem Projekt in dem ich aktuell arbeite, generieren wir unser Datenbank praktisch vollst&Atilde;&curren;ndig per <a href="http:&#47;&#47;www.hibernate.org&#47;397.html">Hibernate Annotations<&#47;a>. Was die Benennung von Tabellen und Spalten angeht, verlassen wir uns dabei praktisch vollst&Atilde;&curren;ndig auf die Standards von Hibernate, die recht brauchbar sind. Eigentlich gibt es nur zwei echte Probleme und eine kleinere Unanehmlichkeit:</p>
<ol>
<li>Oracle unterst&Atilde;&frac14;tzt nur Spaltennamen und Tabellennamen bis zu einer L&Atilde;&curren;nge von 30 Zeichen (<a href="http:&#47;&#47;blogs.ittoolbox.com&#47;oracle&#47;fahdmirza&#47;archives&#47;history-of-oracle-12771">Ende der 70er<&#47;a> war dies vermutlich up-to-date oder sogar fortschrittlich).<&#47;li>
<li>Werden mehrere gleichartige Objekte '<a href="http:&#47;&#47;www.hibernate.org&#47;hib_docs&#47;ejb3-api&#47;javax&#47;persistence&#47;Embedded.html">Embedded<&#47;a>' in einer Entit&Atilde;&curren;t so gibt es einen <a href="http:&#47;&#47;forum.hibernate.org&#47;viewtopic.php?t=967323&amp;highlight=">Namenskonflikt<&#47;a>.<&#47;li>
<li>Standardm&Atilde;&curren;&Atilde;&Yuml;ig geht die Gliederung eines Namens durch CamelCasing verloren, wenn er  in Tabellen und Spaltennamen umgewandelt werden. (z.B. wird aus tollerAttributName einfach TOLLERATTRIBUTNAME. Viele w&Atilde;&frac14;rden TOLLER_ATTRIBUT_NAME bevorzugen.<&#47;li><br />
<&#47;ol><br />
F&Atilde;&frac14;r Problem 2. und 3. gibt es eine fertige L&Atilde;&para;sung: <tt>DefaultComponentSafeNamingStrategy<&#47;tt>, die einfach vor der Erzeugung der SessionFactory in der Konfiguration gesetzt wird:</p>
<p><code>Configuration config = new AnnotationConfiguration().configure();<br />
config.setNamingStrategy(new DefaultComponentSafeNamingStrategy());<br />
sessionFactory = config.buildSessionFactory();<&#47;code></p>
<p>Auf der Suche nach dieser L&Atilde;&para;sung bin ich auch bei ein paar Seiten vorbeigekommen, bei denen <a href="http:&#47;&#47;reverttoconsole.com&#47;archives&#47;97">Namenskonvention <&#47;a>mit Hilfe einer Namingstrategy umgesetzt werden.</p>
<blockquote><p>we extended the ImprovedNamingStrategy further to handle pluralization of tablenames<&#47;blockquote><br />
Das verletzt zwar das Prinzip: Don't repeat yourself, denn niemand w&Atilde;&frac14;rde wohl erwarten, dass die <tt>CUSTOMER<&#47;tt> Tabelle nur einen Kunden enth&Atilde;&curren;lt, aber wer's mag. Immer noch besser als <a href="http:&#47;&#47;www.jroller.com&#47;mert&#47;date&#47;20060518">Code Obfuscation<&#47;a></p>
<blockquote><p> class: tr.PopulationCenter &Atilde;&nbsp; table: T_PPLTN_CNTR<br />
property: upperPopulationCenter &Atilde;&nbsp; column: UPPR_PPLTN_CNTR<&#47;blockquote><br />
Ganz Abseits von der l&Atilde;&curren;nglichen Diskussion &Atilde;&frac14;ber Codeconventionen, so ist die Idee, sie per NamingStrategy umzusetzen, doch definitiv eine Gute. Ich habe mein neu gewonnenes Wissen erstmal ausprobiert um eine Namingstrategy zu konstruieren, die Tabellen und Spaltennamen auf 30 Zeichen k&Atilde;&frac14;rzt, hoffentlich ohne dabei v&Atilde;&para;llig unleserlich zu werden. Der Algorithmus wandelt Namen wie <tt>Auftragsbestaetigung_Rueckantwort_lineitem<&#47;tt> um in <tt>Auftragsb_Rueckantw_lineitem<&#47;tt>. Der Algorithmus sucht nach dem l&Atilde;&curren;ngsten Teilst&Atilde;&frac14;ck und k&Atilde;&frac14;rzt es um die letzen Vokale inklusive eventuell nachfolgender Konsonanten. Dies wird wiederholt, bis der Name maximal noch 30 Zeichen lang ist.</p>
<p><tt>Auftragsbestaetigung<&#47;tt> aus dem obigen Beispiel wird also der Reihe nach <tt>Auftragsbestaetig<&#47;tt>, <tt>Auftragsbestaet<&#47;tt>, <tt>Auftragsbest<&#47;tt> und schlie&Atilde;&Yuml;lich <tt>Auftragsbest<&#47;tt></p>
<pre>
<p>import java.util.StringTokenizer;</p>
<p>import org.hibernate.cfg.DefaultComponentSafeNamingStrategy;</p>
<p>public class OracleNamingStrategy<br />
     extends DefaultComponentSafeNamingStrategy<br />
{</p>
<p>  @Override<br />
  public String collectionTableName(String ownerEntity,<br />
      String ownerEntityTable, String associatedEntity,<br />
      String associatedEntityTable, String propertyName)<br />
  {<br />
    return abbreviateName(super.collectionTableName(<br />
        ownerEntity,<br />
        ownerEntityTable, associatedEntity,<br />
        associatedEntityTable, propertyName));<br />
  }</p>
<p>  @Override<br />
  public String foreignKeyColumnName(String propertyName,<br />
      String propertyEntityName, String propertyTableName,<br />
      String referencedColumnName)<br />
  {<br />
    return abbreviateName(super.foreignKeyColumnName(<br />
        propertyName,<br />
        propertyEntityName, propertyTableName,<br />
        referencedColumnName));<br />
  }</p>
<p>  @Override<br />
  public String logicalCollectionColumnName(<br />
      String columnName,<br />
      String propertyName,<br />
      String referencedColumn)<br />
  {<br />
    return abbreviateName(super.logicalCollectionColumnName(<br />
        columnName,<br />
        propertyName, referencedColumn));<br />
  }</p>
<p>  @Override<br />
  public String logicalCollectionTableName(String tableName,<br />
      String ownerEntityTable, String associatedEntityTable,<br />
      String propertyName)<br />
  {<br />
    return abbreviateName(super.logicalCollectionTableName(<br />
        tableName,<br />
        ownerEntityTable, associatedEntityTable,<br />
        propertyName));<br />
  }</p>
<p>  @Override<br />
  public String logicalColumnName(String columnName,<br />
        String propertyName)<br />
  {<br />
    return abbreviateName(super.logicalColumnName(<br />
        columnName, propertyName));<br />
  }</p>
<p>  @Override<br />
  public String propertyToColumnName(String propertyName)<br />
  {<br />
    return abbreviateName(<br />
        super.propertyToColumnName(propertyName));<br />
  }</p>
<p>  private static final int MAX_LENGTH = 30;</p>
<p>  public static String abbreviateName(String someName)<br />
  {<br />
    if (someName.length() <= MAX_LENGTH) return someName;</p>
<p>    String[] tokens = splitName(someName);<br />
    shortenName(someName, tokens);</p>
<p>    return assembleResults(tokens);<br />
  }</p>
<p>  private static String[] splitName(String someName)<br />
  {<br />
    StringTokenizer toki = new StringTokenizer(someName, "_");<br />
    String[] tokens = new String[toki.countTokens()];<br />
    int i = 0;<br />
    while (toki.hasMoreTokens())<br />
    {<br />
      tokens[i] = toki.nextToken();<br />
      i++;<br />
    }<br />
    return tokens;<br />
  }</p>
<p>  private static void shortenName(<br />
       String someName, String[] tokens)<br />
  {<br />
    int currentLength = someName.length();<br />
    while (currentLength > MAX_LENGTH)<br />
    {<br />
      int tokenIndex = getIndexOfLongest(tokens);<br />
      String oldToken = tokens[tokenIndex];<br />
      tokens[tokenIndex] = abbreviate(oldToken);<br />
      currentLength -=<br />
           oldToken.length() - tokens[tokenIndex].length();<br />
    }<br />
  }</p>
<p>  private static String assembleResults(String[] tokens)<br />
  {<br />
    StringBuilder result = new StringBuilder(tokens[0]);<br />
    for (int j = 1; j < tokens.length; j++)<br />
    {<br />
      result.append("_").append(tokens[j]);<br />
    }<br />
    return result.toString();<br />
  }</p>
<p>  private static String abbreviate(String token)<br />
  {<br />
    final String VOWELS = "AEIOUaeiou";<br />
    boolean vowelFound = false;<br />
    for (int i = token.length() - 1; i >= 0; i--)<br />
    {<br />
      if (!vowelFound)<br />
        vowelFound = VOWELS.contains(<br />
             String.valueOf(token.charAt(i)));<br />
      else if (!VOWELS.contains(String.valueOf(token.charAt(i))))<br />
        return token.substring(0, i + 1);<br />
    }<br />
    return "";<br />
  }</p>
<p>  private static int getIndexOfLongest(String[] tokens)<br />
  {<br />
    int maxLength = 0;<br />
    int index = -1;<br />
    for (int i = 0; i < tokens.length; i++)<br />
    {<br />
      String string = tokens[i];<br />
      if (maxLength < string.length())<br />
      {<br />
        maxLength = string.length();<br />
        index = i;<br />
      }<br />
    }<br />
    return index;<br />
  }<br />
}<&#47;pre><br />
Das ganze ist im Halbschlaf entstanden und weder gr&Atilde;&frac14;ndlich getestet noch intensiv genutzt worden. Benutzung also auf eigene Gefahr. Sollte es sich aber als praktisch erweisen, so wie es ist, oder in abgewandelter Form so w&Atilde;&frac14;rde ich mich sehr &Atilde;&frac14;ber einen entsprechenden Kommentar freuen</p>
