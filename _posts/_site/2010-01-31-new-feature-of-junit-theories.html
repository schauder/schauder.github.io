<p>A couple of months ago I blogged about <a href="&#47;2009&#47;10&#47;04&#47;junit-rules&#47;">JUnit Rules<&#47;a>, one of the new features in JUnit. While fooling around with JUnit Rules, I found a couple more features that you might be interested in. So here it comes: Theories! It turns out Theories are really a piece of cake. Try this:</p>
<pre lang="java">import static org.junit.Assume.assumeTrue;<br />
import org.junit.experimental.theories.DataPoint;<br />
import org.junit.experimental.theories.Theories;<br />
import org.junit.experimental.theories.Theory;<br />
import org.junit.runner.RunWith;</p>
<p>@RunWith(Theories.class)<br />
public class TheorieTest {</p>
<p>	@DataPoint<br />
	public static String a = "a";</p>
<p>	@DataPoint<br />
	public static String b = "bb";</p>
<p>	@DataPoint<br />
	public static String c = "ccc";</p>
<p>	@Theory<br />
	public void stringTest(String x, String y) {<br />
		assumeTrue(x.length() > 1);</p>
<p>		System.out.println(x + " " + y);<br />
	}<br />
}<&#47;pre><br />
When you run this you'll get this as an output (and one successfull test):</p>
<pre>bb a<br />
bb bb<br />
bb ccc<br />
ccc a<br />
ccc bb<br />
ccc ccc<&#47;pre><br />
So what is going on? The first thing to note is that this test is executed by a specialized runner of type Theories. This runner executes all the public methods annotated with @Theory. Differently from normal tests theories have parameters. In order to fill these parameters with values, the Theories runner uses all the public fields of matching Type and annotated with @DataPoint. When you take a look at the output, it should be obvious why this is more powerful then <a href="http:&#47;&#47;ourcraft.wordpress.com&#47;2008&#47;08&#47;27&#47;writing-a-parameterized-junit-test&#47;">parameterized Tests<&#47;a>: Every combination of values is tried, thus with e.g. 4 parameters with 4 distinct values each, you end up with 256 test runs.</p>
<p>The idea is to specify a theory about the object under test, that holds for a large class of states and parameters.&Acirc;&nbsp; Then you provide those as parameters to the test method which will test the theory.</p>
<p>A probably very common case is that a theory is known not to be valid for certain cases. You can exclude these from a test using the Assume class. If an assumption doesn't hold, the test is silently ignored. This is used in the example above to prevent 'a' to be used as a first parameter.</p>
<p>There are some more tweaks to Theories in JUnit, which I will cover in a later blog. Until then enjoy the new feature. But keep in mind the package in which theories reside up to now: <tt>org.junit.<strong>experimental<&#47;strong>.theories <&#47;tt> so I'd expect some changes in the API and at least a change in package name.</p>
