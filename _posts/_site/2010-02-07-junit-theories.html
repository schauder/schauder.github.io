<p>In my last <a href="&#47;2010&#47;01&#47;31&#47;new-feature-of-junit-theories&#47;">blog post<&#47;a>, I described how to use JUnit Theories to create large amounts of test runs, with very limited amount of work, like so:</p>
<pre lang="java">import static org.junit.Assume.assumeTrue;<br />
@RunWith(Theories.class)<br />
public class TheorieTest {</p>
<p>	@DataPoint<br />
	public static String a = "a";</p>
<p>	@DataPoint<br />
	public static String b = "bb";</p>
<p>	@DataPoint<br />
	public static String c = "ccc";</p>
<p>	@Theory<br />
	public void stringTest(String x, String y) {<br />
		assumeTrue(x.length() > 1);</p>
<p>		System.out.println(x + " " + y);<br />
	}<br />
}<&#47;pre><br />
The trick is simple to provide data points for every parameter type of the test method. The JUnit Theories Runner will call the test method with every possible combination of datapoints. If you think a little about it you will soon realize some of the limitations of this approach:</p>
<ul>
<li>You'll soon end up with lots of data point fields cluttering your code<&#47;li>
<li>Parameters of the same type will receive the same set of parameters, even when the usable range of inputs is completely different.<&#47;li><br />
<&#47;ul><br />
Fortunately the developers of JUnit provided really nice solutions to these problems.</p>
<p>Instead of specifying single data points, you can provide a full array of datapoints using the <tt>@Datapoints<&#47;tt> annotation, like so (add imports for good measure):</p>
<pre lang="java">@RunWith(Theories.class)<br />
public class TheorieTest {</p>
<p>	@DataPoints<br />
	public static String[] a = { "a", "bb", "ccc" };</p>
<p>	@DataPoints<br />
	public static Integer[] j = { 1, 2, 3 };</p>
<p>	@Theory<br />
	public void someTest(String x, Integer y) {<br />
		assumeTrue(x.length() > 1);</p>
<p>		System.out.println(x + " " + y);<br />
	}<br />
}<br />
<&#47;pre><br />
This of course is much less verbose. Instead of an array you may provide a method returning an array, or at least it looks like this should be possible. But when I tried it JUnit seemed unable to handle the types correctly resulting in IllegalArgumentExceptions. Guess I'll have to file a bug when finished with this article ...</p>
<p>But we still need to take care of parameters which have the same type, but very different meaning and therefore different useful values. The clean OO way of doing things would be to get rid of the generic types like <tt>String<&#47;tt> and use stronger types like <tt>CreditCardNumber<&#47;tt> or <tt>Name<&#47;tt> instead. But then in a perfect world we wouldn't need tests, because our programs wouldn't contain any bugs to begin with. So lets try this instead (Again imports omitted):</p>
<pre lang="java">@Retention(RetentionPolicy.RUNTIME)<br />
@ParametersSuppliedBy(CreditCardSupplier.class)<br />
public @interface AllCreditCards {}</p>
<p>&#47;&#47;-----------------------------------------------------------------</p>
<p>@Retention(RetentionPolicy.RUNTIME)<br />
@ParametersSuppliedBy(NameSupplier.class)<br />
public @interface AllNames {}</p>
<p>&#47;&#47;-----------------------------------------------------------------</p>
<p>public class CreditCardSupplier extends ParameterSupplier {</p>
<p>	@Override<br />
	public List getValueSources(<br />
			ParameterSignature signature) {</p>
<p>		ArrayList result = new ArrayList();</p>
<p>		result.add(PotentialAssignment.forValue("Amex", "Amex"));<br />
		result.add(PotentialAssignment.forValue("Master", "Master"));<br />
		result.add(PotentialAssignment.forValue("Visa", "Visa"));</p>
<p>		return result;<br />
	}<br />
}</p>
<p>&#47;&#47;-----------------------------------------------------------------</p>
<p>public class NameSupplier extends ParameterSupplier {</p>
<p>	@Override<br />
	public List getValueSources(<br />
			ParameterSignature signature) {</p>
<p>		AllNames annotation = signature.getAnnotation(AllNames.class);<br />
		System.out.println("just wanted to show that I can access it "<br />
				+ annotation);</p>
<p>		ArrayList result = new ArrayList();</p>
<p>		result.add(PotentialAssignment.forValue("Alf", "Alf"));<br />
		result.add(PotentialAssignment.forValue("Willie", "Willie"));<br />
		result.add(PotentialAssignment.forValue("Tanner", "Tanner"));<br />
		result.add(PotentialAssignment.forValue("Cat", "Cat"));</p>
<p>		return result;<br />
	}<br />
}</p>
<p>&#47;&#47;-----------------------------------------------------------------</p>
<p>@RunWith(Theories.class)<br />
public class SuppliedByTest {</p>
<p>	@Theory<br />
	public void imagineThisIsATest(@AllCreditCards String x, @AllNames String y) {<br />
		System.out.println("consider " + x + " &#47; " + y + " tested.");<br />
	}</p>
<p>	@Theory<br />
	public void testIntegers(@TestedOn(ints = { 2, 3, 4, 7, 13, 23, 42 }) int i) {<br />
		System.out.println(i);<br />
	}<br />
}<br />
<&#47;pre><br />
Wow, thats a lot of code. Just look at the last piece and see what appears in the console when we run it:</p>
<pre>just wanted to show that I can access it @de.schauderhaft.junit.theories.AllNames()<br />
consider Amex &#47; Alf tested.<br />
consider Amex &#47; Willie tested.<br />
consider Amex &#47; Tanner tested.<br />
consider Amex &#47; Cat tested.<br />
just wanted to show that I can access it @de.schauderhaft.junit.theories.AllNames()<br />
consider Master &#47; Alf tested.<br />
consider Master &#47; Willie tested.<br />
consider Master &#47; Tanner tested.<br />
consider Master &#47; Cat tested.<br />
just wanted to show that I can access it @de.schauderhaft.junit.theories.AllNames()<br />
consider Visa &#47; Alf tested.<br />
consider Visa &#47; Willie tested.<br />
consider Visa &#47; Tanner tested.<br />
consider Visa &#47; Cat tested.<br />
2<br />
3<br />
4<br />
7<br />
13<br />
23<br />
42<br />
<&#47;pre><br />
Have a look at the row beginning with: "consider". Obviously the Theory <tt>imagineThisIsATest<&#47;tt> gets fed with the values from the <tt>CreditCardSupplier<&#47;tt> and <tt>NameSupplier<&#47;tt>. The parameters and the 'Suppliers' are connected by the two annotations <tt>@AllNames<&#47;tt> and <tt>AllCreditCards<&#47;tt>. So whenever you have a parameter to a theory where the type alone is not sufficient for identifying the kind of values that should get used, you can simple create an annotation, which itself is annotated with a reference to a <tt>ParameterSupplier<&#47;tt> class and you are all set. You might think this is a lot of code for supplying a handful of parameters. You are right, but remember, that you can reuse your suppliers wherever you need names or credit card values in your tests.</p>
<p>Now let's look at the first line of the output:<br />
<tt>just wanted to show that I can access it @de.schauderhaft.junit.theories.AllNames()<&#47;tt><br />
It simply shows of that you get access to the annotation (and actually the signature of the compete test method. This can be very useful, when you want your supplier to behave differently for different theories. Have a look at the <tt>NameSupplier<&#47;tt> above to see how this works.</p>
<p>JUnit actually comes with an example where this is used, and I demonstrated it with the other theory in the demonstration code above. The <tt>@TestedOn<&#47;tt> annotation takes an array of values to be used as data points for the annotated parameter.</p>
<p>Thats it for today. I hope the power of theories became obvious, as well as the power you have as a developer to extend that mechanism. Again be warned: All this nice stuff is in a package named experimental for good reason. If you use it, you might find bugs, and thing will likely change at least in name in an upcoming version. Taking about versions, I am using junit4.8.1 for the examples.</p>
<p>For next week the conclusion of the little series about JUnit theories is planned, with a few thoughts on use and danger of this kind of testing.</p>
