<p>I guess everybody who knows Java and Swing also knows the <a href="http:&#47;&#47;download.oracle.com&#47;javase&#47;tutorial&#47;uiswing&#47;">Swing Tutorial<&#47;a>. It is a great source of information if you want to learn Swing. It is also a major catastrophy when it comes to structuring code. The problem is: Lots of people miss critical information contained in the tutorial like 'Everything concerned with Swing must happen in the EDT' but they seem to suck up the messy way to structure code like a sponge.</p>
<p>This might result in code like the one below. It is actually Scala code, but that shouldn't matter much. The only piece that is a little special are the calls to <tt>Binder<&#47;tt>, which is a little <a href="&#47;2011&#47;05&#47;01&#47;binding-scala-objects-to-swing-components&#47;">Swing Binding Framework<&#47;a> which I introduced a couple of weeks ago.</p>
<pre lang="scala">    private def createPersonPanel(p : PersonEditor) = {<br />
        val panel = new JPanel()<br />
        val layout = new GridBagLayout()<br />
        val c = new GridBagConstraints()<br />
        c.gridx = 0<br />
        c.gridy = 0</p>
<p>        panel.setLayout(layout)</p>
<p>        c.fill = 0<br />
        panel.add(new JLabel("firstname"), c)</p>
<p>        c.fill = 1<br />
        c.gridx += 1<br />
        c.weightx = 1<br />
        val firstnameTF = new JTextField()<br />
        panel.add(firstnameTF, c)<br />
        Binder.bind(p.firstname, firstnameTF)</p>
<p>        c.fill = 0<br />
        c.weightx = 0<br />
        c.gridx = 0<br />
        c.gridy += 1</p>
<p>        panel.add(new JLabel("lastname"), c)<br />
        c.fill = 1</p>
<p>        c.gridx += 1<br />
        val lastnameTF = new JTextField()<br />
        Binder.bind(p.lastname, lastnameTF)<br />
        panel.add(lastnameTF, c)<br />
        c.fill = 0<br />
        c.weightx = 1<br />
        c.gridy += 1<br />
        c.anchor = GridBagConstraints.SOUTHEAST<br />
        val button = new JButton("save")<br />
        Binder.bind(p.save, button)<br />
        panel.add(button, c)<br />
        panel<br />
    }<&#47;pre><br />
What is so bad about this piece of crap ... &Atilde;&curren;hm ... code?</p>
<p>The method is long. 38 lines is about 10 times longer than healthy for a method.</p>
<p>There is tons of code duplication.</p>
<p>The method does lots of different things: creating components, adding them to a panel, configuring the layout.</p>
<p>There is a strong dependency on the order of commands. We can't just move stuff up or down in the method and still hope the result will be something reasonable, even if we stick to rearrangements allowed by the compiler.</p>
<p>All this together makes the method extremely hard to understand. How long does it take to understand what kind of GUI results? Don't bother to much, I help. It looks like this:</p>
<p><a href="http:&#47;&#47;blog.schauderhaft.de&#47;wp-content&#47;uploads&#47;2011&#47;06&#47;small.png"><img class="alignnone size-full wp-image-824" title="Image of the Frame in packed state." src="http:&#47;&#47;blog.schauderhaft.de&#47;wp-content&#47;uploads&#47;2011&#47;06&#47;small.png" alt="" width="132" height="104" &#47;><&#47;a></p>
<p>and if you resize it, it looks like this</p>
<p><a href="http:&#47;&#47;blog.schauderhaft.de&#47;wp-content&#47;uploads&#47;2011&#47;06&#47;large.png"><img class="alignnone size-full wp-image-825" title="Resized Frame" src="http:&#47;&#47;blog.schauderhaft.de&#47;wp-content&#47;uploads&#47;2011&#47;06&#47;large.png" alt="" width="315" height="214" &#47;><&#47;a></p>
<p>Arguably the result looks just as ugly as the code, but once the code is clean we might be able to improve on the visual design as well.</p>
<p>If you don't see it in the code, you might see it in the images: There are three different ways JComponents are handled by the method: <tt>JLabels<&#47;tt> are in the left column and don't resize. The <tt>JTextField<&#47;tt>s are in the right column and do resize and the JButton doesn't resize and is in the buttom right. In the code this is completely hidden in the manipulation of the <tt>GridBagConstraint<&#47;tt>. So lets make it explicit in the code:</p>
<pre lang="scala">    private def addToLabelColumn(<br />
        panel : JPanel,<br />
        component : JComponent,<br />
        row : Int) {<br />
        val c = new GridBagConstraints()<br />
        c.gridx = 0<br />
        c.gridy = row<br />
        c.weightx = 0<br />
        c.fill = 0<br />
        panel.add(component, c)<br />
    }</p>
<p>    private def addToComponentColumn(<br />
        panel : JPanel,<br />
        component : JComponent,<br />
        row : Int) {<br />
        val c = new GridBagConstraints()<br />
        c.gridx = 1<br />
        c.gridy = row<br />
        c.weightx = 1<br />
        c.fill = 1<br />
        panel.add(component, c)<br />
    }</p>
<p>    private def addButton(<br />
        panel : JPanel,<br />
        component : JButton,<br />
        row : Int) {<br />
        val c = new GridBagConstraints()</p>
<p>        c.weightx = 1<br />
        c.gridx = 1<br />
        c.gridy = row<br />
        c.fill = 0<br />
        c.anchor = GridBagConstraints.SOUTHEAST<br />
        panel.add(component, c)<br />
    }</p>
<p>    private def createPersonPanel(p : PersonEditor) = {<br />
        val panel = new JPanel()<br />
        val layout = new GridBagLayout()<br />
        panel.setLayout(layout)</p>
<p>        addToLabelColumn(panel, new JLabel("firstname"), 0)</p>
<p>        val firstnameTF = new JTextField()<br />
        Binder.bind(p.firstname, firstnameTF)<br />
        addToComponentColumn(panel, firstnameTF, 0)</p>
<p>        addToLabelColumn(panel, new JLabel("lastname"), 1)</p>
<p>        val lastnameTF = new JTextField()<br />
        Binder.bind(p.lastname, lastnameTF)<br />
        addToComponentColumn(panel, lastnameTF, 1)</p>
<p>        val button = new JButton("save")<br />
        Binder.bind(p.save, button)<br />
        addButton(panel, button, 2)<br />
        panel<br />
    }<&#47;pre><br />
I introduced three methods. One for adding a JLabel, one for adding a JComponent and one for adding JButtons. These handle the arrangement of components on a JPanel. The total length of the code increased because we create the GridBagConstraints insided the methods and have to set all properties and don't rely anymore on the previous step to leave the constraint in a specific state.</p>
<p>If we now look at the <tt>createPersonPanel<&#47;tt> we'll get a strong fealing of repetition in various places:</p>
<ul>
<li>each call to add* methods takes the same JPanel as an argument. We can improve on this by creating a Builder wich crates the panel, contains the add* methods and can return the fully configured panel at the end.<&#47;li>
<li>for each property we create a <tt>JLabel<&#47;tt>, a <tt>JTextField<&#47;tt>, bind the property to the later and add both to the <tt>JPanel<&#47;tt>. We can fix this by encapsulating it in a seperate method.<&#47;li><br />
<&#47;ul><br />
The result might look like this:</p>
<pre lang="scala">
    case class PanelBuilder() {<br />
        val panel = new JPanel()<br />
        val layout = new GridBagLayout()<br />
        panel.setLayout(layout)</p>
<p>        def add(components : (JLabel, JComponent), row : Int) {<br />
            addToLabelColumn(components._1, row)<br />
            addToComponentColumn(components._2, row)<br />
        }</p>
<p>        def add(<br />
            component : JButton,<br />
            row : Int) {<br />
            val c = new GridBagConstraints()</p>
<p>            c.weightx = 1<br />
            c.gridx = 1<br />
            c.gridy = row<br />
            c.fill = 0<br />
            c.anchor = GridBagConstraints.SOUTHEAST<br />
            panel.add(component, c)<br />
        }</p>
<p>        private def addToLabelColumn(<br />
            component : JComponent,<br />
            row : Int) {<br />
            val c = new GridBagConstraints()<br />
            c.gridx = 0<br />
            c.gridy = row<br />
            c.weightx = 0<br />
            c.fill = 0<br />
            panel.add(component, c)<br />
        }</p>
<p>        private def addToComponentColumn(<br />
            component : JComponent,<br />
            row : Int) {<br />
            val c = new GridBagConstraints()<br />
            c.gridx = 1<br />
            c.gridy = row<br />
            c.weightx = 1<br />
            c.fill = 1<br />
            panel.add(component, c)<br />
        }</p>
<p>    }</p>
<p>    private def create(name : String, property : Property[String]) : (JLabel, JComponent) = {<br />
        val textField = new JTextField()<br />
        Binder.bind(property, textField)<br />
        (new JLabel(name), textField)<br />
    }</p>
<p>    private def create(name : String, action : => Unit) = {<br />
        val button = new JButton("save")<br />
        Binder.bind(action, button)<br />
        button<br />
    }</p>
<p>    private def createPersonPanel(p : PersonEditor) = {<br />
        val builder = PanelBuilder()</p>
<p>        builder.add(create("firstname", p.firstname), 0)<br />
        builder.add(create("lastname", p.lastname), 1)<br />
        builder.add(create("save", p.save), 2)</p>
<p>        builder.panel<br />
    }<br />
<&#47;pre></p>
<p>The <tt>PanelBuilder<&#47;tt> has now two simple public <tt>add<&#47;tt> methods. In order to imitate the method signitures in Java we would have to create a couple of helper classes and interfaces. It would make the code less compact but this shouldn't be a serious problem. Creation of the various components is just as the binding extracted in two create Methods. The <tt>createPersonPanel<&#47;tt> has now only 5 lines of code. Adding another property to the form should be trivial. Changing the extremely simplistic layout should be trivial and is at least limited to a single small class. I think this is pretty much OK for a first step toward clean swing code. So I leave it like it is right now. Although I do have further plans for this.</p>
<p>I hope most of you agree that the code is much easier to understand and maintain in the form it is right now. But is it really worth the effort? Some might say no. If the whole application would consist of only this little panel. I would agree. But a Swing application typically does not have a single panel with two textfields and a button. But tens or even hundreds of panels. Many consisting of large collections of components. If you have to maintain such a monster, would you prefer createPersonPanel methods like the last one, or would you prefer the first version? What if the customer if finally fed up with your crappy layout and insists on proper spacing between the labels and the <tt>JTextFields<&#47;tt> or other components?</p>
<p>All this is pretty nice when you start a new Swing application. But what if you have an existing Swing application? One with convoluted code just as the Swing Tutorial taught you? Well ... start changing it now. Don't sit down for two months and rewrite all your code, but find pieces of code duplication and extract them. It will be a long way, but you wont reach the end if you don't start walking.</p>
<p>But what if you are not using Swing, but writing a web application? Well it really shouldn't matter much. Your PanelBuilder might be written in JavaScript, or create HTML, but the principle is the same: Seperate creation of components, layout of components and binding of components to properties and actions.</p>
