<p>My favorite feature in the <a href="&#47;2011&#47;07&#47;24&#47;rules-in-junit-4-9-beta-3&#47;">JUnit are Rules<&#47;a>. With Rules you can manipulate the execution of your test, by wrapping your own code around the test execution. I have used this for setting up <a href="&#47;2011&#47;03&#47;13&#47;testing-databases-with-junit-and-hibernate-part-1-one-to-rule-them&#47;">databases for test<&#47;a>, making sure they <a href="&#47;2010&#47;08&#47;15&#47;use-cases-for-junit-rules&#47;">execute in the EDT<&#47;a>, limiting legal test execution time and for set up and tear down of various other resources.</p>
<p>So naturally when working with <a href="&#47;2010&#47;12&#47;26&#47;testing-with-scala&#47;">ScalaTest<&#47;a> I pretty soon wanted to have something equivalent to Rules. While you find not much when searching for 'Rules ScalaTest', it is actually quite easy to implement.</p>
<p>No matter what kind of tests you write with ScalaTest, at the end of the day the method <tt>def withFixture(aTest : NoArgTest)<&#47;tt> will get called with your test to execute. 'Your test' means in case of a FunSuite test the stuff between the curly braces that you pass to the <tt>test<&#47;tt> method.</p>
<p>The implementation of <tt>withFixture<&#47;tt> will finally execute your test. So all you have to do in order to get the equivalent of a JUnit Rule is to override <tt>withFixture<&#47;tt>. Lets give it a try:</p>
<pre lang="scala">
class ExampleTest extends FunSuite {</p>
<p>    override def withFixture(test : NoArgTest){<br />
        println<br />
        println("before")<br />
        super.withFixture(test)<br />
        println("after")<br />
    }</p>
<p>    test("example test"){<br />
        println("succeding test")<br />
    }</p>
<p>    test("example failing test"){<br />
        println("failing test")<br />
        fail("embrace failure")<br />
    }<br />
}<br />
<&#47;pre></p>
<p>This produces the following output on the console:</p>
<pre>
<p>before<br />
succeding test<br />
after</p>
<p>before<br />
failing test<br />
<&#47;pre></p>
<p>As you can see, if you want to do stuff after the test, you better put it in a <tt>finally<&#47;tt> block, so it gets executed no matter if the test fails or not.</p>
<p>While this works, we don't want to explicitly override <tt>withFixture<&#47;tt> every time we need our 'rule'. The solution to this is to extract it into a trait:</p>
<pre lang="scala">
trait ExampleRule extends AbstractSuite {<br />
    self : Suite =><br />
    override abstract def withFixture(test : NoArgTest) {<br />
        println<br />
        println("before")<br />
        try {<br />
            ExampleRule.super.withFixture(test)<br />
        } finally {<br />
            println("after")<br />
        }<br />
    }<br />
}</p>
<p>class Example2Test extends FunSuite with ExampleRule {<br />
    test("example test") {<br />
        println("succeding test")<br />
    }</p>
<p>    test("example failing test") {<br />
        println("failing test")<br />
        fail("embrace failure")<br />
    }<br />
}<br />
<&#47;pre></p>
<p>The trait extends AbstractSuite, which makes <tt>withFixture<&#47;tt> available. It has a selftype of Suite, in order to ensure it gets only mixed into test suites.</p>
<p>So how does this solution compare to the implementation of a JUnit Rule? With a Junit Rule we have to create the actual Rule plus a Statement instance. With ScalaTest we only extend a single trait. Also since all this is standard Scala inheritance an no reflection involved, so it is pretty strait forward to find out how this works. While how and why a Rule gets executed is kind of tricky from the source alone. Finally you can explicitly control the order in which your traits apply, by controlling the order in which you put them in the extends clause:</p>
<pre lang="scala">
trait Example3Rule extends AbstractSuite {<br />
    self : Suite =><br />
    override abstract def withFixture(test : NoArgTest) {<br />
        println("3 before")<br />
        try {<br />
            Example3Rule.super.withFixture(test)<br />
        } finally {<br />
            println("3 after")<br />
        }<br />
    }<br />
}</p>
<p>@RunWith(classOf[JUnitRunner])<br />
class Example3Test extends FunSuite  with Example3Rule with ExampleRule{<br />
    test("example test") {<br />
        println("succeding test")<br />
    }</p>
<p>    test("example failing test") {<br />
        println("failing test")<br />
        fail("embrace failure")<br />
    }<br />
}<br />
<&#47;pre></p>
<pre>
before<br />
3 before<br />
succeding test<br />
3 after<br />
after</p>
<p>before<br />
3 before<br />
failing test<br />
3 after<br />
after<br />
<&#47;pre></p>
<p>With Junit Rules there is currently no ready to use way to do this, but a feature to achieve this <a href="https:&#47;&#47;github.com&#47;stefanbirkner&#47;junit&#47;commit&#47;3584c44bedd8705f30dda4f4213fa45655b998c7">is in development<&#47;a>.</p>
