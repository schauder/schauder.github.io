<p>When people working on a multitiered application get asked to draw their architecture, often something like this emerges:</p>
<p><tt>UI -> Domain -> Persistence<&#47;tt></p>
<p>This is all nice until you start to wonder what the arrows actually mean. </p>
<p>Is it data flow? Probably not, except when you are working on an application that takes input, stores it somewhere but never retrieves it back.</p>
<p>Is it dependencies? Hopefully not, or everything depends on your persistence layer. You really don't want that.</p>
<p>It might be calls: The UI gets triggered by the user in some way (say hitting a save button). The UI calls the domain logic tod do its stuff which in tern calls the persistence layer to store the stuff, load some other stuff and this gets returned up the stack until it gets displayed in the UI.</p>
<p>While this is valid information to convey it often isn't what people think they are conveying. Instead they claim this are dependencies. And maybe they are. But if you want to document your dependencies your diagram should look like this most of the time:</p>
<p><tt>UI -> Domain <- Persistence<&#47;tt></p>
<p>The Domain should be the center of your architecture and there for at the center of your dependencies. Everything else, i.e. all the interfaces (in the general sense) should depend on the domain. Not the other way round. </p>
<p>You achieve that by defining interfaces (in the Java sense) <strong>inside your domain<&#47;strong> which then get implemented or used by the UI or the Persistence layer.</p>
<p>If you want you can have those interfaces in seperate layers you can:</p>
<p><tt>UI -> Presentation Interface  Persistence Interface <- Persistence Implementation<&#47;tt></p>
<p>Just take care that the design of the <strong>Presentation Interface<&#47;strong> and the <strong>Persistence Interface<&#47;strong> is driven by the domain, not by some UI or Persistence technology. </p>
<p>As a side note: If you are using Hibernate &#47; JPA with annotation based mapping you are either violating this design principle, because your persistence technology (JPA) bleeds into the domain logic (annotations on the domain classes) or you have to copy all the data from your entity classes into your domain classes which really is cumbersome and reintroduces the kind of boilerplate code we wanted to get rid of with tools like Hibernate in the first place.</p>
<p>How to resolve that issue is a topic for another day.</p>
