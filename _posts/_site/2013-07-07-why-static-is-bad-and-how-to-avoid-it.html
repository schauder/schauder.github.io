<p>Everybody who worked with a project which included a <tt>StringUtil(s)<&#47;tt> class with only static methods, raise her hand! Thought so. Are those methods bad? Probably not so much, although I had a word to say about the name, after all if a class is not a utility it isn't useful (<a href="http:&#47;&#47;en.wiktionary.org&#47;wiki&#47;utility">by the definition of Wiktionary<&#47;a>) and we hopefully haven't much of that kind in our projects.</p>
<p>But static methods turn bad, when they become more complex than the typical content of a <tt>StringUtil<&#47;tt> class. The problem is your code becomes hard wired to that static method. There is no easy way to replace the reference to the static method with something else, and if you are testing your code using automated tests, this is exactly what you want to do.</p>
<p><a href="&#47;2011&#47;07&#47;31&#47;getting-started-with-testing&#47;">If you don't test your code using automated tests, do something about it NOW!<&#47;a></p>
<p>Converting a static method to something easily mocked is straight forward once you've done it once or twice. Lets start with an example:</p>
<pre lang="java">
public class Utility{<br />
    public static int doSomething(){<br />
        &#47;&#47;...<br />
    }<br />
}</p>
<p>public class Client{<br />
    public void foo(){<br />
        &#47;&#47;...<br />
        Utility.doSomething();<br />
        &#47;&#47;...<br />
    }<br />
}<br />
<&#47;pre></p>
<p>The <tt>Client<&#47;tt> uses a static method in <tt>Utility<&#47;tt> and we want to get rid of that. The first step is to make the <tt>doSomething<&#47;tt> method non-static. It is really as easy as removing the static modifier. Of course now the <tt>Client<&#47;tt> needs and instance of <tt>Utility<&#47;tt>, so we just create one for now:</p>
<pre lang="java">
public class Utility{<br />
    public int doSomething(){<br />
        &#47;&#47;...<br />
    }<br />
}</p>
<p>public class Client{<br />
    public void foo(){<br />
        &#47;&#47;...<br />
        new Utility().doSomething();<br />
        &#47;&#47;...<br />
    }<br />
}<br />
<&#47;pre> </p>
<p>Of course this doesn't improve the situation much. We still have a static reference to the <tt>Utility<&#47;tt> class, since the constructor is  just another static method. But now we can simply inject the dependency from the outside:</p>
<pre lang="java">
public class Utility{<br />
    public int doSomething(){<br />
        &#47;&#47;...<br />
    }<br />
}</p>
<p>public class Client{<br />
    private final Utility utility;</p>
<p>    public Client(Utility aUtility){<br />
        utility = aUtility;<br />
    }</p>
<p>    public void foo(){<br />
        &#47;&#47;...<br />
        utility.doSomething();<br />
        &#47;&#47;...<br />
    }<br />
}<br />
<&#47;pre> </p>
<p>Now you can replace <tt>Utility<&#47;tt> by a mocked instance for tests, you can use a wrapped instance for logging or make it implement an interface and so one. Basically you are back in OO world. Of course you can use your favorite DI-Framework to inject the dependency (<a href="&#47;2012&#47;01&#47;01&#47;the-one-correct-way-to-do-dependency-injection&#47;">just make sure you do it properly<&#47;a>), or if you don't mind the compile time dependency you can create an alternative constructor in the <tt>Client<&#47;tt> which uses the default implementation.</p>
