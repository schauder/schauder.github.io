<p>For a long time JSF for me was just another webframework I didn't cared too much about. This changed. After being forced to use it for a couple of months now, I consider it a major project risk in almost all cases. Here I present the reasons for this verdict.</p>
<p><strong>Bad entanglement of UI and processing Logic<&#47;strong> The <a href="http:&#47;&#47;docs.oracle.com&#47;javaee&#47;6&#47;tutorial&#47;doc&#47;bnapj.html">official tutorial claims the following about the benefits of JSF<&#47;a>: </p>
<blockquote><p>One of the greatest advantages of Java Server Faces technology is that it offers a clean separation between behavior and presentation for web applications.<&#47;blockquote></p>
<p>The opposite is the case. Facelets, the preferred presentation technology of JSF looks at first sight like an ordinary templating technology like the good old <a href="http:&#47;&#47;en.wikipedia.org&#47;wiki&#47;JavaServer_Pages">JSP <&#47;a>or <a href="http:&#47;&#47;www.thymeleaf.org&#47;">Thyme Leaf<&#47;a>. But if you look closer the horror becomes obvious. In the same place where you structure your HTML, you also place the logic what parts of the UI should get updated on an action. A clear violation of the separation of concerns principle in my book. </p>
<p>Even better is the <tt>immediate<&#47;tt> attribute which <a href="http:&#47;&#47;blog.jerryorr.com&#47;2012&#47;01&#47;jsf-and-immediate-attribute-command.html">changes the server side life cycle!<&#47;a> And if this isn't enough it does it in different ways <a href="http:&#47;&#47;balusc.blogspot.de&#47;2006&#47;09&#47;debug-jsf-lifecycle.html#AddImmediateTrueToUIInputOnly">depending on what tag you use it<&#47;a> on. You can't make stuff like this up.</p>
<p><strong>It tries to abstract what you can not abstract.<&#47;strong> Except some weird edge cases clients and server of web application are located on rather different computers, separated by some kind of network. From this follows a simple fact: communication between client and server is slow and unreliable. JSF tries to abstract away the separation of client and server. It processes everything on the backend wildly communicating between client and server in a hard to control way. The result are all kind of failure scenarios just popping into existence because you use JSF. For me the most annoying one is this one: If you open a JSF page, let's say a simple search page, wait an hour, then hit the submit button you will get an exception because the server side state expired. WAT? Why is there server state of any relevance for a trivial search page? (Yes I know you can change that behavior with the latest versions of JSF, but it is still the way JSF is designed to work) I though everybody learned since EJBs: If you want to abstract over the fact, if two parts of an application run on the same machine or not, you have to assume they don't. Everything else is just hiding problems until they grow so large that they can eat your project for breakfast.</p>
<p><strong>Making stuff complex and complicated that was easy to start with.<&#47;strong> <a href="http:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Representational_state_transfer">The architecture of the World Wide Web is a simple one<&#47;a>. Simple meaning: It consists of a small set of concepts with limited interaction. This is what made it so widely successful. It also makes it not obvious for beginners how to use it to implement certain features. I'm sure most of us remember the first time they tried to implement something like a shopping cart without having session state. But the solutions for almost all these problems are well known and understood by know. And all you need is a little reading and what you gain is a strong conceptual understanding how to solve this kind of issue. And again, the basics are extremely simple: You send a request to an URL, with some headers and content using a HTTP verb. And you reply with some resource containing links and some headers. And you don't have state in the server session. Making load balancing and fail over rather simple. Making bookmarkable URLs trivial. Making your site searchable for zero costs. Making your site cachable. Allowing the user to use their back buttons, history and tabs as they wish. Making it trivial to have nice URLs</p>
<p>Compare that to the live cycle model of JSF: The page from which a user submitted a request will get synchronized with a model on the server side, then submitted values validated, converted, events generated and processed. As mentioned above the order in which things happen, and if they happen at all are controlled by XML Tags hidden away in a document camouflaged as markup. Apart from hardly anybody properly understanding all this (<a href="http:&#47;&#47;stackoverflow.com&#47;users&#47;157882&#47;balusc">BalusC seems to be the only one available in the interwebs<&#47;a>) it has the following effect on your application: The URLs become ugly. You'll see the URL of the resource you came from instead of the one you are looking at, thus making bookmarking URLs as useful as a doorknob on your knee. Same for caching, fail over, load balancing and so on. </p>
<p>Sure you can fix it with some convention here, and an additional library there. Which of course makes perfect sense when you are in the business of breaking stuff so people have to pay you for fixing it. I personally prefer helping to solve real problems.</p>
<p><strong>Hindering testability:<&#47;strong> I can't speak for most frameworks but I can compare Spring MVC with JSF. Let me tell you this: If anybody is telling you JSF is nicely testable he probably doesn't know automatic testing. With JSF you can test your backend beans using unit tests. You can test the whole UI, by deploying the application to a server and hitting it with Selenium. That's basically it. </p>
<p>Just in case you are wondering what else one should be able to test: Load a static version of a page in a browser and testing it with selenium, in order test your Client side UI behavior. Test your generated markup without starting a full blown application server. Test the mapping of attributes&#47;parameter to bean methods. Test your generated markup without bootstrapping a complete application. All this is perfectly possible with Spring MVC and probably with many other sane server side frameworks, but not with JSF ...</p>
<p>Again: I'm aware there are fixes for many issues, but the simplest fix is> <strong>Don't use JSF<&#47;strong>.</p>
