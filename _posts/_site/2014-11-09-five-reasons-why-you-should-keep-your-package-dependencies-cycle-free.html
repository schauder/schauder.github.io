<p>If you are so unlucky to work with me in a project, you will suffer from the rule that all package dependencies must be cycle free. I will not only require this, but I will also create a unit test ensuring it using <a href="http:&#47;&#47;schauder.github.io&#47;degraph&#47;">Degraph<&#47;a>. Here are the reasons why I think a cycle free package structure is beneficial for a project.</p>
<ol>
<li><strong>Helpful abstractions<&#47;strong>: If you implement stuff without thinking to much about dependencies you end up with cyclic dependencies almost for sure. In order to break those cycles you often have to introduce new abstractions in the form of interfaces. These interfaces often turnout to create a cleaner abstraction of what is going on in the application than the direct dependency that was there before.
<p>For example consider two packages <tt>Something<&#47;tt> and <tt>Other<&#47;tt> that depend on each other. As it is described, there is no way to tell why they depend on each other. But in order to break one of the dependencies you might decide to introduce an interface. The name of that interface might include valuable additional information about the relationship of the two. Imagine the interface ends up being named <tt>SomethingDeletionListener<&#47;tt> and located in <tt>Somehting<&#47;tt> and implemented in <tt>Other<&#47;tt>. This already tells you something about the relationship of the two packages, doesn't it?<&#47;li></p>
<li><strong>Clean Orthogonal Package Structure<&#47;strong>: Whenever you organize something in a tree like structure you probably want an orthogonal structure in that tree. This means on all subbranches of a branch are elements of single categorization. A good example is <tt>Customer<&#47;tt>, <tt>Order<&#47;tt>, <tt>Wishlist<&#47;tt> a different, also good example is <tt>UserInterface<&#47;tt>, <tt>Persistence<&#47;tt>, <tt>Domain<&#47;tt>. These kinds of structures gives a clear indication where a class belongs. If you mix the two approaches you end up with something like <tt>Customer<&#47;tt>, <tt>Order<&#47;tt>, <tt>Persistence<&#47;tt>. In such a structure it is not at all clear where classes for the persistence of customers belong. The result is a mess, which typically results in cycles in the dependencies, since a question like should <tt>Customer<&#47;tt> depend on <tt>Persistence<&#47;tt> or the other way around doesn't even make sense.<&#47;li>
<li><strong>Enables reuse<&#47;strong>: Ever tried to reuse a package or even just a single class from a project that doesn't care about dependencies? I tried. In 9 out of 10 cases I had two choices: Either take the complete project (not really an option), or do some heavy refactoring of the class before it even compiles without all the other stuff in the project. On the other hand in projects where package dependencies form a nice directed acyclic graph, it is perfectly clear what has to go with the class. Also the stuff people are interested in reusing is typically close to the leaves of the graph and can be extracted on it's own or with very few dependencies.<&#47;li>
<li><strong>Enables partial rewrites<&#47;strong>: Sometimes an idea once considered great turns out to be a really bad one. Sometimes it is so bad, you want to redo it. Acyclic dependencies limit the amount of code affected by the change. With cyclic dependencies often the complete application is at least in danger of being affected.<&#47;li>
<li><strong>Independent deployment<&#47;strong>: On the other hand, sometimes ideas actually turn out to be great. Maybe so great that they get used so heavily, that you need to scale it up and deploy it on three additional servers on its own, to handle the heavy load. Good luck in splitting your application in two or more parts that can be deployed separately when you have tangles between the packages. With a cycle free structure, the places where you can cut should be rather obvious.<&#47;li>
<p><&#47;ol></p>
